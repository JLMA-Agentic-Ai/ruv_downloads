/**
 * V3 Workers System - Cross-Platform Background Workers
 *
 * Optimizes Claude Flow with non-blocking, scheduled workers.
 * Works on Linux, macOS, and Windows.
 */
import { EventEmitter } from 'events';
export interface WorkerConfig {
    name: string;
    description: string;
    interval: number;
    enabled: boolean;
    priority: WorkerPriority;
    timeout: number;
    platforms?: ('linux' | 'darwin' | 'win32')[];
}
export declare enum WorkerPriority {
    Critical = 0,
    High = 1,
    Normal = 2,
    Low = 3,
    Background = 4
}
export interface WorkerResult {
    worker: string;
    success: boolean;
    duration: number;
    data?: Record<string, unknown>;
    error?: string;
    alerts?: WorkerAlert[];
    timestamp: Date;
}
export interface WorkerMetrics {
    name: string;
    status: 'running' | 'idle' | 'error' | 'disabled';
    lastRun?: Date;
    lastDuration?: number;
    runCount: number;
    errorCount: number;
    avgDuration: number;
    lastResult?: Record<string, unknown>;
}
export interface WorkerManagerStatus {
    running: boolean;
    platform: string;
    workers: WorkerMetrics[];
    uptime: number;
    totalRuns: number;
    lastUpdate: Date;
}
export type WorkerHandler = () => Promise<WorkerResult>;
export declare enum AlertSeverity {
    Info = "info",
    Warning = "warning",
    Critical = "critical"
}
export interface WorkerAlert {
    worker: string;
    severity: AlertSeverity;
    message: string;
    metric?: string;
    value?: number;
    threshold?: number;
    timestamp: Date;
}
export interface AlertThreshold {
    metric: string;
    warning: number;
    critical: number;
    comparison: 'gt' | 'lt' | 'eq';
}
export declare const DEFAULT_THRESHOLDS: Record<string, AlertThreshold[]>;
export interface PersistedWorkerState {
    version: string;
    lastSaved: string;
    workers: Record<string, {
        lastRun?: string;
        lastResult?: Record<string, unknown>;
        runCount: number;
        errorCount: number;
        avgDuration: number;
    }>;
    history: HistoricalMetric[];
}
export interface HistoricalMetric {
    timestamp: string;
    worker: string;
    metrics: Record<string, number>;
}
export interface StatuslineData {
    workers: {
        active: number;
        total: number;
        errors: number;
    };
    health: {
        status: 'healthy' | 'warning' | 'critical';
        memory: number;
        disk: number;
    };
    security: {
        status: 'clean' | 'warning' | 'critical';
        issues: number;
    };
    adr: {
        compliance: number;
    };
    ddd: {
        progress: number;
    };
    performance: {
        speedup: string;
    };
    alerts: WorkerAlert[];
    lastUpdate: string;
}
export declare const WORKER_CONFIGS: Record<string, WorkerConfig>;
export declare class WorkerManager extends EventEmitter {
    private workers;
    private metrics;
    private timers;
    private running;
    private startTime?;
    private projectRoot;
    private metricsDir;
    private persistPath;
    private statuslinePath;
    private alerts;
    private history;
    private thresholds;
    private statuslineTimer?;
    private autoSaveTimer?;
    private initialized;
    constructor(projectRoot?: string);
    private initializeMetrics;
    /**
     * Load persisted state from disk
     */
    loadState(): Promise<boolean>;
    /**
     * Save current state to disk
     */
    saveState(): Promise<void>;
    /**
     * Check result against thresholds and generate alerts
     */
    private checkAlerts;
    private getNestedValue;
    /**
     * Set custom alert thresholds
     */
    setThresholds(worker: string, thresholds: AlertThreshold[]): void;
    /**
     * Get recent alerts
     */
    getAlerts(limit?: number): WorkerAlert[];
    /**
     * Clear alerts
     */
    clearAlerts(): void;
    /**
     * Record metrics to history
     */
    private recordHistory;
    /**
     * Get historical metrics for a worker
     */
    getHistory(worker?: string, limit?: number): HistoricalMetric[];
    /**
     * Generate statusline data
     */
    getStatuslineData(): StatuslineData;
    /**
     * Export statusline data to file (for shell consumption)
     */
    exportStatusline(): Promise<void>;
    /**
     * Generate shell-compatible statusline string
     */
    getStatuslineString(): string;
    /**
     * Register a worker handler
     * Optionally pass config; if not provided, a default config is used for dynamically registered workers
     */
    register(name: string, handler: WorkerHandler, config?: Partial<WorkerConfig>): void;
    /**
     * Initialize and start workers (loads persisted state)
     */
    initialize(): Promise<void>;
    /**
     * Start all workers with scheduling
     */
    start(options?: {
        autoSave?: boolean;
        statuslineUpdate?: boolean;
    }): Promise<void>;
    /**
     * Stop all workers and save state
     */
    stop(): Promise<void>;
    /**
     * Run a specific worker immediately
     */
    runWorker(name: string): Promise<WorkerResult>;
    /**
     * Run all workers (non-blocking with concurrency limit)
     */
    runAll(concurrency?: number): Promise<WorkerResult[]>;
    /**
     * Get worker status
     */
    getStatus(): WorkerManagerStatus;
    /**
     * Get statusline-friendly metrics
     */
    getStatuslineMetrics(): Record<string, unknown>;
    private scheduleWorker;
    private ensureMetricsDir;
}
export declare function createPerformanceWorker(projectRoot: string): WorkerHandler;
export declare function createHealthWorker(projectRoot: string): WorkerHandler;
export declare function createSwarmWorker(projectRoot: string): WorkerHandler;
export declare function createGitWorker(projectRoot: string): WorkerHandler;
export declare function createLearningWorker(projectRoot: string): WorkerHandler;
export declare function createADRWorker(projectRoot: string): WorkerHandler;
export declare function createDDDWorker(projectRoot: string): WorkerHandler;
export declare function createSecurityWorker(projectRoot: string): WorkerHandler;
export declare function createPatternsWorker(projectRoot: string): WorkerHandler;
export declare function createCacheWorker(projectRoot: string): WorkerHandler;
export declare function createWorkerManager(projectRoot?: string): WorkerManager;
export declare const workerManager: WorkerManager;
//# sourceMappingURL=index.d.ts.map