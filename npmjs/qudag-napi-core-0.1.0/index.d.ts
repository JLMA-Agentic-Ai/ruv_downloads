/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Generate a quantum fingerprint (convenience function)
 *
 * Creates a quantum fingerprint and returns its bytes directly.
 *
 * # Arguments
 * * `data` - The data to fingerprint
 *
 * # Returns
 * The fingerprint bytes (64 bytes)
 *
 * # Example
 * ```js
 * const data = Buffer.from("Important data");
 * const fingerprintBytes = generateQuantumFingerprint(data);
 * ```
 */
export declare function generateQuantumFingerprint(data: Buffer): Uint8Array
/**
 * Verify data against a fingerprint (convenience function)
 *
 * Note: This function is simplified and only compares fingerprint data.
 * For full verification with signatures, use the QuantumFingerprint class.
 *
 * # Arguments
 * * `data` - The data to verify
 * * `expected_fingerprint` - The expected fingerprint bytes
 *
 * # Returns
 * `true` if the fingerprints match, `false` otherwise
 */
export declare function verifyQuantumFingerprint(data: Buffer, expectedFingerprint: Buffer): boolean
/** HQC keypair */
export interface HqcKeyPair {
  /** Public key bytes */
  publicKey: Uint8Array
  /** Secret key bytes */
  secretKey: Uint8Array
}
/** HQC algorithm information */
export interface HqcInfo {
  /** NIST security level */
  securityLevel: number
  /** Algorithm identifier */
  algorithm: string
  /** Public key size in bytes */
  publicKeySize: number
  /** Secret key size in bytes */
  secretKeySize: number
  /** Ciphertext size in bytes */
  ciphertextSize: number
}
/** ML-DSA algorithm information */
export interface MlDsaInfo {
  /** Size of public keys in bytes */
  publicKeySize: number
  /** Size of secret keys in bytes */
  secretKeySize: number
  /** Size of signatures in bytes */
  signatureSize: number
  /** NIST security level (1-5, where 3 corresponds to AES-192) */
  securityLevel: number
  /** Algorithm identifier */
  algorithm: string
}
/**
 * Get ML-DSA algorithm information
 *
 * Returns detailed information about the ML-DSA-65 parameter set.
 *
 * # Example
 * ```js
 * const info = getMlDsaInfo();
 * console.log(`Public key size: ${info.publicKeySize} bytes`);
 * console.log(`Security level: ${info.securityLevel}`);
 * ```
 */
export declare function getMlDsaInfo(): MlDsaInfo
/**
 * ML-KEM key pair
 *
 * Contains both the public key (for encapsulation) and secret key (for decapsulation).
 */
export interface MlKemKeyPair {
  /** Public key (1184 bytes) - can be shared with others */
  publicKey: Uint8Array
  /** Secret key (2400 bytes) - must be kept secret */
  secretKey: Uint8Array
}
/**
 * ML-KEM encapsulation result
 *
 * Contains the ciphertext (to send to recipient) and shared secret (for encryption).
 */
export interface MlKemEncapsulation {
  /** Ciphertext (1088 bytes) - send this to the recipient */
  ciphertext: Uint8Array
  /** Shared secret (32 bytes) - use this for symmetric encryption */
  sharedSecret: Uint8Array
}
/** ML-KEM algorithm information */
export interface MlKemInfo {
  /** Size of public keys in bytes */
  publicKeySize: number
  /** Size of secret keys in bytes */
  secretKeySize: number
  /** Size of ciphertexts in bytes */
  ciphertextSize: number
  /** Size of shared secrets in bytes */
  sharedSecretSize: number
  /** NIST security level (3 = AES-192 equivalent) */
  securityLevel: number
  /** Algorithm identifier */
  algorithm: string
}
/** DAG vertex representation */
export interface Vertex {
  /** Unique vertex identifier (usually a hex string) */
  id: string
  /** Vertex payload data */
  payload: Buffer
  /** Parent vertex IDs */
  parents: Array<string>
  /** Optional timestamp (milliseconds since Unix epoch) */
  timestamp?: number
}
/** Consensus status for a vertex (simplified) */
export const enum ConsensusStatus {
  /** Vertex is pending consensus */
  Pending = 'Pending',
  /** Vertex has reached consensus */
  Accepted = 'Accepted',
  /** Vertex has been finalized */
  Final = 'Final',
  /** Vertex was rejected */
  Rejected = 'Rejected'
}
/** Get the version of the @qudag/napi-core package */
export declare function getVersion(): string
/** Get build information */
export declare function getBuildInfo(): BuildInfo
/** Build information */
export interface BuildInfo {
  /** Package version */
  version: string
  /** Rust compiler version used for building */
  rustcVersion: string
  /** Target architecture */
  target: string
  /** Operating system */
  os: string
}
/**
 * Quantum fingerprint for data verification
 *
 * Quantum fingerprints provide a compact, quantum-resistant way to verify
 * data integrity using ML-DSA signatures.
 */
export declare class QuantumFingerprint {
  /**
   * Generate a quantum fingerprint for data
   *
   * Creates a quantum-resistant fingerprint of the input data.
   * The fingerprint can be used to verify data integrity.
   *
   * # Arguments
   * * `data` - The data to fingerprint
   *
   * # Example
   * ```js
   * const data = Buffer.from("Important data");
   * const fingerprint = QuantumFingerprint.generate(data);
   * const fpBytes = fingerprint.asBytes();
   * ```
   */
  static generate(data: Buffer): QuantumFingerprint
  /**
   * Get the fingerprint as bytes
   *
   * Returns the raw fingerprint bytes (64 bytes from BLAKE3).
   */
  asBytes(): Uint8Array
  /**
   * Get the fingerprint as a hex string
   *
   * Convenient for displaying or transmitting the fingerprint.
   */
  asHex(): string
  /**
   * Get the signature bytes
   *
   * Returns the ML-DSA signature over the fingerprint.
   */
  getSignature(): Uint8Array
  /**
   * Get the public key bytes
   *
   * Returns the ML-DSA public key used for verification.
   */
  getPublicKey(): Uint8Array
  /**
   * Verify the fingerprint
   *
   * Verifies the ML-DSA signature over the fingerprint data.
   *
   * # Returns
   * `true` if the signature is valid, `false` otherwise
   *
   * # Example
   * ```js
   * const data = Buffer.from("Important data");
   * const fingerprint = QuantumFingerprint.generate(data);
   *
   * // Verify the fingerprint
   * const isValid = fingerprint.verify();
   * console.log(`Fingerprint is ${isValid ? "valid" : "invalid"}`);
   * ```
   */
  verify(): boolean
}
/**
 * HQC-128 quantum-resistant encryption (security level 1)
 *
 * Provides encryption and decryption using the HQC (Hamming Quasi-Cyclic)
 * post-quantum cryptosystem at security level 1 (equivalent to AES-128).
 */
export declare class Hqc128Wrapper {
  /**
   * Generate a keypair for HQC-128
   *
   * # Returns
   * A tuple of (public_key, secret_key)
   */
  static keygen(): HqcKeyPair
  /** Get algorithm information */
  static getInfo(): HqcInfo
}
/**
 * HQC-192 quantum-resistant encryption (security level 3)
 *
 * Provides encryption and decryption using HQC at security level 3
 * (equivalent to AES-192).
 */
export declare class Hqc192Wrapper {
  /**
   * Generate a keypair for HQC-192
   *
   * # Returns
   * A tuple of (public_key, secret_key)
   */
  static keygen(): HqcKeyPair
  /** Get algorithm information */
  static getInfo(): HqcInfo
}
/**
 * HQC-256 quantum-resistant encryption (security level 5)
 *
 * Provides encryption and decryption using HQC at security level 5
 * (equivalent to AES-256).
 */
export declare class Hqc256Wrapper {
  /**
   * Generate a keypair for HQC-256
   *
   * # Returns
   * A tuple of (public_key, secret_key)
   */
  static keygen(): HqcKeyPair
  /** Get algorithm information */
  static getInfo(): HqcInfo
}
/**
 * ML-DSA key pair for quantum-resistant digital signatures
 *
 * This class provides methods for generating key pairs and signing messages
 * using the ML-DSA (CRYSTALS-Dilithium) post-quantum signature algorithm.
 */
export declare class MlDsaKeyPair {
  /**
   * Generate a new ML-DSA key pair
   *
   * Creates a new quantum-resistant key pair using ML-DSA-65 (security level 3).
   * This uses secure random number generation internally.
   *
   * # Example
   * ```js
   * const keypair = MlDsaKeyPair.generate();
   * ```
   */
  static generate(): MlDsaKeyPair
  /**
   * Get the public key as a Uint8Array
   *
   * Returns the raw public key bytes (1952 bytes for ML-DSA-65).
   * This can be safely shared with others for signature verification.
   */
  publicKey(): Uint8Array
  /**
   * Get the public key as a hex string
   *
   * Convenient method for displaying or transmitting the public key as hexadecimal.
   */
  publicKeyHex(): string
  /**
   * Sign a message with this key pair
   *
   * Creates a quantum-resistant digital signature for the given message.
   * The signature size is approximately 3309 bytes for ML-DSA-65.
   *
   * # Arguments
   * * `message` - The message to sign (any length)
   *
   * # Returns
   * A Uint8Array containing the signature
   *
   * # Example
   * ```js
   * const message = Buffer.from("Hello, quantum world!");
   * const signature = keypair.sign(message);
   * ```
   */
  sign(message: Buffer): Uint8Array
  /**
   * Sign a message deterministically (for testing)
   *
   * This creates a deterministic signature without using randomness.
   * **WARNING**: Only use this for testing! Production code should use `sign()`.
   */
  signDeterministic(message: Buffer): Uint8Array
  /**
   * Convert to public key for sharing
   *
   * Extracts the public key component for distribution to others.
   */
  toPublicKey(): MlDsaPublicKey
}
/**
 * ML-DSA public key for signature verification
 *
 * This class represents a public key that can verify ML-DSA signatures.
 * Public keys can be freely shared and do not contain any secret material.
 */
export declare class MlDsaPublicKey {
  /**
   * Create public key from bytes
   *
   * # Arguments
   * * `bytes` - Raw public key bytes (must be exactly 1952 bytes for ML-DSA-65)
   */
  static fromBytes(bytes: Buffer): MlDsaPublicKey
  /**
   * Create public key from hex string
   *
   * # Arguments
   * * `hex_string` - Hexadecimal representation of the public key
   */
  static fromHex(hexString: string): MlDsaPublicKey
  /** Get public key bytes as Uint8Array */
  asBytes(): Uint8Array
  /** Get public key as hex string */
  asHex(): string
  /**
   * Verify a signature
   *
   * Verifies that a signature was created by the private key corresponding to this public key.
   *
   * # Arguments
   * * `message` - The original message that was signed
   * * `signature` - The signature to verify
   *
   * # Returns
   * `true` if the signature is valid, `false` otherwise
   *
   * # Example
   * ```js
   * const isValid = publicKey.verify(message, signature);
   * if (isValid) {
   *   console.log("Signature is valid!");
   * }
   * ```
   */
  verify(message: Buffer, signature: Buffer): boolean
  /**
   * Batch verify multiple signatures
   *
   * Efficiently verifies multiple signatures at once.
   * This is faster than verifying each signature individually.
   *
   * # Arguments
   * * `messages` - Array of messages
   * * `signatures` - Array of signatures (must match messages length)
   * * `public_keys` - Array of public keys (must match messages length)
   *
   * # Returns
   * `true` if all signatures are valid, `false` if any are invalid
   */
  static batchVerify(messages: Array<Buffer>, signatures: Array<Buffer>, publicKeys: Array<MlDsaPublicKey>): boolean
}
/**
 * ML-KEM-768 key encapsulation mechanism
 *
 * This class provides static methods for quantum-resistant key exchange
 * using the ML-KEM (Kyber) algorithm at security level 3.
 */
export declare class MlKem {
  /**
   * Generate a new ML-KEM-768 key pair
   *
   * Creates a new key pair for key encapsulation. The public key can be shared
   * with others to allow them to encapsulate shared secrets.
   *
   * # Returns
   * An object containing both the public key and secret key
   *
   * # Example
   * ```js
   * const { publicKey, secretKey } = MlKem.keygen();
   * ```
   */
  static keygen(): MlKemKeyPair
  /**
   * Encapsulate a shared secret
   *
   * Uses a public key to encapsulate a random shared secret. The recipient
   * can use their secret key to decapsulate and recover the same shared secret.
   *
   * # Arguments
   * * `public_key` - The recipient's public key (1184 bytes)
   *
   * # Returns
   * An object containing the ciphertext and shared secret
   *
   * # Example
   * ```js
   * const { ciphertext, sharedSecret } = MlKem.encapsulate(publicKey);
   * // Send ciphertext to recipient
   * // Use sharedSecret for encryption
   * ```
   */
  static encapsulate(publicKey: Buffer): MlKemEncapsulation
  /**
   * Decapsulate a shared secret
   *
   * Uses a secret key to recover the shared secret from a ciphertext.
   * This should produce the same shared secret that was generated during encapsulation.
   *
   * # Arguments
   * * `secret_key` - Your secret key (2400 bytes)
   * * `ciphertext` - The ciphertext received from the sender (1088 bytes)
   *
   * # Returns
   * The shared secret (32 bytes)
   *
   * # Example
   * ```js
   * const sharedSecret = MlKem.decapsulate(secretKey, ciphertext);
   * // Use sharedSecret for decryption
   * ```
   */
  static decapsulate(secretKey: Buffer, ciphertext: Buffer): Uint8Array
  /**
   * Get ML-KEM-768 parameters
   *
   * Returns information about the ML-KEM-768 algorithm parameters.
   *
   * # Example
   * ```js
   * const info = MlKem.getInfo();
   * console.log(`Shared secret size: ${info.sharedSecretSize} bytes`);
   * ```
   */
  static getInfo(): MlKemInfo
}
export type QuantumDAG = QuantumDag
/**
 * Quantum-resistant DAG with simplified consensus
 *
 * This is a basic implementation that stores vertices and tracks their relationships.
 * Future versions will include full QR-Avalanche consensus protocol.
 */
export declare class QuantumDag {
  /** Create a new QuantumDAG instance */
  constructor()
  /**
   * Add a vertex to the DAG
   *
   * # Arguments
   * * `vertex` - The vertex to add
   *
   * # Example
   * ```js
   * const dag = new QuantumDAG();
   * await dag.addVertex({
   *   id: "vertex-1",
   *   payload: Buffer.from("data"),
   *   parents: [],
   *   timestamp: Date.now()
   * });
   * ```
   */
  addVertex(vertex: Vertex): Promise<void>
  /**
   * Add a message to the DAG (convenience method)
   *
   * Automatically creates a vertex from a payload and adds it to the DAG.
   *
   * # Arguments
   * * `payload` - The message payload
   *
   * # Returns
   * The vertex ID (hex encoded hash of the payload)
   */
  addMessage(payload: Buffer): Promise<string>
  /**
   * Get current DAG tips (vertices with no children)
   *
   * Tips are vertices that have been added but haven't been referenced
   * as parents by other vertices yet.
   */
  getTips(): Promise<Array<string>>
  /**
   * Check if the DAG contains a vertex
   *
   * # Arguments
   * * `vertex_id` - The vertex ID to check
   */
  containsVertex(vertexId: string): Promise<boolean>
  /** Get the number of vertices in the DAG */
  vertexCount(): Promise<number>
  /**
   * Get a vertex by ID
   *
   * # Arguments
   * * `vertex_id` - The vertex ID
   *
   * # Returns
   * The vertex data, or null if not found
   */
  getVertex(vertexId: string): Promise<Vertex | null>
}
