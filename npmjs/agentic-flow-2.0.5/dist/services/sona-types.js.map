{"version":3,"file":"sona-types.js","sourceRoot":"","sources":["../../src/services/sona-types.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAgHH;;GAEG;AACH,MAAM,OAAO,eAAe;IAC1B;;OAEG;IACH,MAAM,CAAC,iBAAiB,CACtB,SAAmB,EACnB,cAAsB,IAAI,EAC1B,OAAe,WAAW;QAE1B,IAAI,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;YAC5C,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,0BAA0B,OAAO,SAAS,EAAE,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,SAAS,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CACb,GAAG,IAAI,YAAY,WAAW,UAAU,SAAS,CAAC,MAAM,GAAG,CAC5D,CAAC;QACJ,CAAC;QAED,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAC/D,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,4CAA4C,CAAC,CAAC;QACvE,CAAC;IACH,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,eAAe,CAAC,OAAe,EAAE,OAAe,SAAS;QAC9D,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;YACtD,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,iCAAiC,OAAO,EAAE,CAAC,CAAC;QACrE,CAAC;QAED,IAAI,OAAO,GAAG,CAAC,IAAI,OAAO,GAAG,CAAC,EAAE,CAAC;YAC/B,MAAM,IAAI,KAAK,CACb,GAAG,IAAI,iCAAiC,OAAO,EAAE,CAClD,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,cAAc,CACnB,YAAsB,EACtB,SAAmB,EACnB,cAAsB,IAAI;QAE1B,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;QAClE,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;IAC9D,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,YAAY,CAAC,SAAiB,EAAE,UAAkB,OAAO,CAAC,GAAG,EAAE;QACpE,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;QAE7B,2BAA2B;QAC3B,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC;YAC3C,CAAC,CAAC,SAAS;YACX,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QAElC,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAE1C,gCAAgC;QAChC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;YAClC,MAAM,IAAI,KAAK,CACb,4BAA4B,SAAS,kCAAkC,CACxE,CAAC;QACJ,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF","sourcesContent":["/**\n * TypeScript interfaces for SONA engine\n *\n * Replaces 'any' types with proper interfaces for type safety\n */\n\nexport interface SONAPattern {\n  id: string;\n  avgQuality: number;\n  similarity: number;\n  context?: string;\n  embedding?: number[];\n  route?: string;\n}\n\nexport interface SONAStats {\n  totalPatterns: number;\n  avgQuality: number;\n  trajectories: number;\n  trajectoryUtilization: number;\n  routes: Record<string, number>;\n  qualityDistribution: {\n    high: number;\n    medium: number;\n    low: number;\n  };\n}\n\nexport interface LearnResult {\n  patternsLearned: number;\n  quality: number;\n  convergence: boolean;\n  epochs: number;\n}\n\nexport interface TrajectoryContext {\n  route?: string;\n  metadata: Record<string, string>;\n}\n\n/**\n * SONA Engine Interface\n *\n * Core methods for trajectory management and LoRA adaptation\n */\nexport interface SONAEngine {\n  /**\n   * Begin a new trajectory for learning\n   * @param embedding - Initial embedding vector (should be 3072D)\n   * @returns Trajectory ID\n   */\n  beginTrajectory(embedding: number[]): string;\n\n  /**\n   * Set the route (agent/task name) for a trajectory\n   * @param id - Trajectory ID\n   * @param route - Route name\n   */\n  setTrajectoryRoute(id: string, route: string): void;\n\n  /**\n   * Add context metadata to a trajectory\n   * @param id - Trajectory ID\n   * @param context - Context string (format: \"key:value\")\n   */\n  addTrajectoryContext(id: string, context: string): void;\n\n  /**\n   * Add a step to the trajectory with hidden states and attention\n   * @param id - Trajectory ID\n   * @param hiddenStates - Hidden layer activations\n   * @param attentionWeights - Attention scores\n   * @param quality - Quality score (0-1)\n   */\n  addTrajectoryStep(\n    id: string,\n    hiddenStates: number[],\n    attentionWeights: number[],\n    quality: number\n  ): void;\n\n  /**\n   * End a trajectory and trigger LoRA update\n   * @param id - Trajectory ID\n   * @param finalQuality - Final quality score (0-1)\n   */\n  endTrajectory(id: string, finalQuality: number): void;\n\n  /**\n   * Find similar patterns using learned LoRA weights\n   * @param queryEmbedding - Query vector\n   * @param k - Number of results\n   * @returns Array of patterns\n   */\n  findPatterns(queryEmbedding: number[], k: number): SONAPattern[];\n\n  /**\n   * Apply Micro-LoRA adaptation to an embedding\n   * @param embedding - Input embedding\n   * @returns Adapted embedding\n   */\n  applyMicroLora(embedding: number[]): number[];\n\n  /**\n   * Force a learning cycle to update LoRA weights\n   * @returns Learning result\n   */\n  forceLearn(): LearnResult;\n\n  /**\n   * Get engine statistics\n   * @returns Statistics object\n   */\n  getStats(): SONAStats;\n}\n\n/**\n * Validation utilities\n */\nexport class ValidationUtils {\n  /**\n   * Validate embedding dimensions\n   */\n  static validateEmbedding(\n    embedding: number[],\n    expectedDim: number = 3072,\n    name: string = 'embedding'\n  ): void {\n    if (!embedding || !Array.isArray(embedding)) {\n      throw new Error(`${name} must be an array, got ${typeof embedding}`);\n    }\n\n    if (embedding.length !== expectedDim) {\n      throw new Error(\n        `${name} must be ${expectedDim}D, got ${embedding.length}D`\n      );\n    }\n\n    if (embedding.some(v => typeof v !== 'number' || !isFinite(v))) {\n      throw new Error(`${name} contains invalid values (NaN or Infinity)`);\n    }\n  }\n\n  /**\n   * Validate quality score\n   */\n  static validateQuality(quality: number, name: string = 'quality'): void {\n    if (typeof quality !== 'number' || !isFinite(quality)) {\n      throw new Error(`${name} must be a finite number, got ${quality}`);\n    }\n\n    if (quality < 0 || quality > 1) {\n      throw new Error(\n        `${name} must be between 0 and 1, got ${quality}`\n      );\n    }\n  }\n\n  /**\n   * Validate hidden states and attention weights\n   */\n  static validateStates(\n    hiddenStates: number[],\n    attention: number[],\n    expectedDim: number = 3072\n  ): void {\n    this.validateEmbedding(hiddenStates, expectedDim, 'hiddenStates');\n    this.validateEmbedding(attention, expectedDim, 'attention');\n  }\n\n  /**\n   * Sanitize file path to prevent traversal attacks\n   */\n  static sanitizePath(inputPath: string, baseDir: string = process.cwd()): string {\n    const path = require('path');\n\n    // Resolve to absolute path\n    const normalized = path.isAbsolute(inputPath)\n      ? inputPath\n      : path.join(baseDir, inputPath);\n\n    const resolved = path.resolve(normalized);\n\n    // Ensure path is within baseDir\n    if (!resolved.startsWith(baseDir)) {\n      throw new Error(\n        `Path traversal detected: ${inputPath} resolves outside base directory`\n      );\n    }\n\n    return resolved;\n  }\n}\n"]}