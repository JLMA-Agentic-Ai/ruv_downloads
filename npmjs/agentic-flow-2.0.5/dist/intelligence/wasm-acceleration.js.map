{"version":3,"file":"wasm-acceleration.js","sourceRoot":"","sources":["../../src/intelligence/wasm-acceleration.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * WASM Acceleration for Intelligence Layer\n *\n * Provides WASM-accelerated components for the intelligence stack:\n * - HNSW vector indexing (150x faster pattern search)\n * - Semantic matching (intelligent agent routing)\n *\n * Uses @ruvector/edge for browser/edge compatibility.\n * Falls back to pure JS when WASM unavailable.\n */\n\nimport {\n  initRuVectorWasm,\n  isWasmInitialized,\n  RuVectorHnswIndex,\n  RuVectorSemanticMatcher,\n  type HnswSearchResult,\n  type SemanticMatch,\n} from '../wasm/ruvector-edge.js';\nimport { logger } from '../utils/logger.js';\n\n// Default embedding dimension (matches SONA)\nconst DEFAULT_DIM = 128;\n\n//=============================================================================\n// WASM Pattern Index - Fast Pattern Search\n//=============================================================================\n\nexport interface PatternEntry {\n  id: string;\n  embedding: Float32Array;\n  metadata: Record<string, any>;\n  accessCount: number;\n  lastAccessed: number;\n}\n\n/**\n * WASM-accelerated pattern index for fast similarity search\n */\nexport class WasmPatternIndex {\n  private hnswIndex: RuVectorHnswIndex;\n  private patterns: Map<string, PatternEntry> = new Map();\n  private indexToId: Map<number, string> = new Map();\n  private dimensions: number;\n\n  constructor(dimensions: number = DEFAULT_DIM) {\n    this.dimensions = dimensions;\n    this.hnswIndex = new RuVectorHnswIndex(dimensions, 16, 200);\n  }\n\n  /**\n   * Initialize WASM (call once at startup)\n   */\n  static async init(): Promise<boolean> {\n    return await initRuVectorWasm();\n  }\n\n  /**\n   * Add pattern to index\n   */\n  addPattern(id: string, embedding: number[] | Float32Array, metadata: Record<string, any> = {}): void {\n    const vec = embedding instanceof Float32Array\n      ? embedding\n      : new Float32Array(embedding);\n\n    const entry: PatternEntry = {\n      id,\n      embedding: vec,\n      metadata,\n      accessCount: 0,\n      lastAccessed: Date.now(),\n    };\n\n    this.patterns.set(id, entry);\n    const idx = this.hnswIndex.add(vec);\n    this.indexToId.set(idx, id);\n  }\n\n  /**\n   * Search for similar patterns\n   */\n  searchSimilar(\n    queryEmbedding: number[] | Float32Array,\n    k: number = 10,\n    minScore: number = 0\n  ): Array<{ pattern: PatternEntry; distance: number; score: number }> {\n    const vec = queryEmbedding instanceof Float32Array\n      ? queryEmbedding\n      : new Float32Array(queryEmbedding);\n\n    const results = this.hnswIndex.search(vec, k);\n    const output: Array<{ pattern: PatternEntry; distance: number; score: number }> = [];\n\n    for (const result of results) {\n      const id = this.indexToId.get(result.index);\n      if (id) {\n        const pattern = this.patterns.get(id);\n        if (pattern) {\n          // Convert distance to similarity score (1 / (1 + distance))\n          const score = 1 / (1 + result.distance);\n          if (score >= minScore) {\n            // Update access stats\n            pattern.accessCount++;\n            pattern.lastAccessed = Date.now();\n\n            output.push({\n              pattern,\n              distance: result.distance,\n              score,\n            });\n          }\n        }\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Get pattern by ID\n   */\n  getPattern(id: string): PatternEntry | undefined {\n    return this.patterns.get(id);\n  }\n\n  /**\n   * Get all patterns (for persistence)\n   */\n  getAllPatterns(): PatternEntry[] {\n    return Array.from(this.patterns.values());\n  }\n\n  /**\n   * Get index size\n   */\n  size(): number {\n    return this.patterns.size;\n  }\n\n  /**\n   * Check if WASM acceleration is active\n   */\n  isWasmAccelerated(): boolean {\n    return this.hnswIndex.isWasmAccelerated();\n  }\n\n  /**\n   * Get performance stats\n   */\n  getStats(): {\n    patternCount: number;\n    wasmAccelerated: boolean;\n    dimensions: number;\n    totalAccesses: number;\n  } {\n    let totalAccesses = 0;\n    for (const pattern of this.patterns.values()) {\n      totalAccesses += pattern.accessCount;\n    }\n\n    return {\n      patternCount: this.patterns.size,\n      wasmAccelerated: this.isWasmAccelerated(),\n      dimensions: this.dimensions,\n      totalAccesses,\n    };\n  }\n}\n\n//=============================================================================\n// WASM Agent Router - Intelligent Routing\n//=============================================================================\n\nexport interface AgentProfile {\n  agentId: string;\n  embedding: Float32Array;\n  capabilities: string[];\n  successRate: number;\n  avgLatency: number;\n}\n\n/**\n * WASM-accelerated agent router for intelligent task routing\n */\nexport class WasmAgentRouter {\n  private semanticMatcher: RuVectorSemanticMatcher;\n  private agents: Map<string, AgentProfile> = new Map();\n  private dimensions: number;\n\n  constructor(dimensions: number = DEFAULT_DIM) {\n    this.dimensions = dimensions;\n    this.semanticMatcher = new RuVectorSemanticMatcher();\n  }\n\n  /**\n   * Initialize WASM (call once at startup)\n   */\n  static async init(): Promise<boolean> {\n    return await initRuVectorWasm();\n  }\n\n  /**\n   * Register agent for routing\n   */\n  registerAgent(profile: AgentProfile): void {\n    this.agents.set(profile.agentId, profile);\n    this.semanticMatcher.registerAgent(\n      profile.agentId,\n      profile.embedding,\n      profile.capabilities\n    );\n  }\n\n  /**\n   * Update agent metrics (success rate, latency)\n   */\n  updateAgentMetrics(agentId: string, successRate: number, avgLatency: number): void {\n    const agent = this.agents.get(agentId);\n    if (agent) {\n      agent.successRate = successRate;\n      agent.avgLatency = avgLatency;\n    }\n  }\n\n  /**\n   * Route task to best agent(s)\n   */\n  routeTask(\n    taskEmbedding: number[] | Float32Array,\n    options: {\n      requiredCapabilities?: string[];\n      minSuccessRate?: number;\n      maxLatency?: number;\n      topK?: number;\n    } = {}\n  ): Array<{\n    agentId: string;\n    score: number;\n    capabilities: string[];\n    successRate: number;\n    avgLatency: number;\n  }> {\n    const {\n      requiredCapabilities = [],\n      minSuccessRate = 0,\n      maxLatency = Infinity,\n      topK = 3,\n    } = options;\n\n    const vec = taskEmbedding instanceof Float32Array\n      ? taskEmbedding\n      : new Float32Array(taskEmbedding);\n\n    // Get semantic matches\n    const matches = this.semanticMatcher.matchTask(vec, topK * 2);\n\n    // Filter and enrich with metrics\n    const results = matches\n      .map(m => {\n        const agent = this.agents.get(m.agent);\n        return {\n          agentId: m.agent,\n          score: m.score,\n          capabilities: m.capabilities,\n          successRate: agent?.successRate ?? 0,\n          avgLatency: agent?.avgLatency ?? 0,\n        };\n      })\n      .filter(r => {\n        // Filter by required capabilities\n        if (requiredCapabilities.length > 0) {\n          const hasAll = requiredCapabilities.every(cap =>\n            r.capabilities.includes(cap)\n          );\n          if (!hasAll) return false;\n        }\n\n        // Filter by success rate\n        if (r.successRate < minSuccessRate) return false;\n\n        // Filter by latency\n        if (r.avgLatency > maxLatency) return false;\n\n        return true;\n      })\n      .slice(0, topK);\n\n    return results;\n  }\n\n  /**\n   * Get agent profile\n   */\n  getAgent(agentId: string): AgentProfile | undefined {\n    return this.agents.get(agentId);\n  }\n\n  /**\n   * Get all registered agents\n   */\n  getAllAgents(): AgentProfile[] {\n    return Array.from(this.agents.values());\n  }\n\n  /**\n   * Check if WASM acceleration is active\n   */\n  isWasmAccelerated(): boolean {\n    return this.semanticMatcher.isWasmAccelerated();\n  }\n\n  /**\n   * Get router stats\n   */\n  getStats(): {\n    agentCount: number;\n    wasmAccelerated: boolean;\n    dimensions: number;\n    avgSuccessRate: number;\n    avgLatency: number;\n  } {\n    let totalSuccess = 0;\n    let totalLatency = 0;\n    let count = 0;\n\n    for (const agent of this.agents.values()) {\n      totalSuccess += agent.successRate;\n      totalLatency += agent.avgLatency;\n      count++;\n    }\n\n    return {\n      agentCount: this.agents.size,\n      wasmAccelerated: this.isWasmAccelerated(),\n      dimensions: this.dimensions,\n      avgSuccessRate: count > 0 ? totalSuccess / count : 0,\n      avgLatency: count > 0 ? totalLatency / count : 0,\n    };\n  }\n}\n\n//=============================================================================\n// Factory Functions\n//=============================================================================\n\nlet patternIndexInstance: WasmPatternIndex | null = null;\nlet agentRouterInstance: WasmAgentRouter | null = null;\n\n/**\n * Get or create singleton pattern index\n */\nexport function getWasmPatternIndex(dimensions: number = DEFAULT_DIM): WasmPatternIndex {\n  if (!patternIndexInstance) {\n    patternIndexInstance = new WasmPatternIndex(dimensions);\n    logger.info('Created WASM pattern index', {\n      dimensions,\n      wasmAccelerated: patternIndexInstance.isWasmAccelerated(),\n    });\n  }\n  return patternIndexInstance;\n}\n\n/**\n * Get or create singleton agent router\n */\nexport function getWasmAgentRouter(dimensions: number = DEFAULT_DIM): WasmAgentRouter {\n  if (!agentRouterInstance) {\n    agentRouterInstance = new WasmAgentRouter(dimensions);\n    logger.info('Created WASM agent router', {\n      dimensions,\n      wasmAccelerated: agentRouterInstance.isWasmAccelerated(),\n    });\n  }\n  return agentRouterInstance;\n}\n\n/**\n * Initialize WASM acceleration for intelligence layer\n */\nexport async function initWasmAcceleration(): Promise<{\n  initialized: boolean;\n  patternIndex: WasmPatternIndex;\n  agentRouter: WasmAgentRouter;\n}> {\n  const initialized = await initRuVectorWasm();\n\n  const patternIndex = getWasmPatternIndex();\n  const agentRouter = getWasmAgentRouter();\n\n  logger.info('WASM acceleration initialized for intelligence layer', {\n    wasmAvailable: initialized,\n    patternIndexAccelerated: patternIndex.isWasmAccelerated(),\n    agentRouterAccelerated: agentRouter.isWasmAccelerated(),\n  });\n\n  return {\n    initialized,\n    patternIndex,\n    agentRouter,\n  };\n}\n\n/**\n * Get WASM acceleration status\n */\nexport function getWasmAccelerationStatus(): {\n  initialized: boolean;\n  patternIndex: boolean;\n  agentRouter: boolean;\n  speedup: string;\n} {\n  return {\n    initialized: isWasmInitialized(),\n    patternIndex: patternIndexInstance?.isWasmAccelerated() ?? false,\n    agentRouter: agentRouterInstance?.isWasmAccelerated() ?? false,\n    speedup: isWasmInitialized() ? '150x vs brute-force' : 'JS fallback',\n  };\n}\n\nexport default {\n  WasmPatternIndex,\n  WasmAgentRouter,\n  getWasmPatternIndex,\n  getWasmAgentRouter,\n  initWasmAcceleration,\n  getWasmAccelerationStatus,\n};\n"]}