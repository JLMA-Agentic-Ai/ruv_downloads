{"version":3,"file":"hooks-bridge.js","sourceRoot":"","sources":["../../src/sdk/hooks-bridge.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * SDK Hooks Bridge - Connects agentic-flow intelligence layer to Claude Agent SDK hooks\n *\n * Bridges our custom hooks (intelligence-bridge.ts) with the native SDK hook system\n * enabling seamless integration with Claude Code's event loop.\n */\n\nimport { logger } from \"../utils/logger.js\";\n\n// Types from Claude Agent SDK (inferred from documentation)\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PostToolUseFailure'\n  | 'Notification'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'PreCompact'\n  | 'PermissionRequest';\n\nexport interface BaseHookInput {\n  session_id: string;\n  transcript_path: string;\n  cwd: string;\n  permission_mode?: string;\n}\n\nexport interface PreToolUseHookInput extends BaseHookInput {\n  hook_event_name: 'PreToolUse';\n  tool_name: string;\n  tool_input: unknown;\n}\n\nexport interface PostToolUseHookInput extends BaseHookInput {\n  hook_event_name: 'PostToolUse';\n  tool_name: string;\n  tool_input: unknown;\n  tool_response: unknown;\n}\n\nexport interface SessionStartHookInput extends BaseHookInput {\n  hook_event_name: 'SessionStart';\n  source: 'startup' | 'resume' | 'clear' | 'compact';\n}\n\nexport interface SessionEndHookInput extends BaseHookInput {\n  hook_event_name: 'SessionEnd';\n  reason: string;\n}\n\nexport interface SubagentStartHookInput extends BaseHookInput {\n  hook_event_name: 'SubagentStart';\n  agent_id: string;\n  agent_type: string;\n}\n\nexport interface SubagentStopHookInput extends BaseHookInput {\n  hook_event_name: 'SubagentStop';\n  stop_hook_active: boolean;\n}\n\nexport type HookInput =\n  | PreToolUseHookInput\n  | PostToolUseHookInput\n  | SessionStartHookInput\n  | SessionEndHookInput\n  | SubagentStartHookInput\n  | SubagentStopHookInput\n  | BaseHookInput & { hook_event_name: string };\n\nexport interface HookJSONOutput {\n  continue?: boolean;\n  suppressOutput?: boolean;\n  stopReason?: string;\n  decision?: 'approve' | 'block';\n  systemMessage?: string;\n  reason?: string;\n  hookSpecificOutput?: {\n    hookEventName: string;\n    additionalContext?: string;\n    permissionDecision?: 'allow' | 'deny' | 'ask';\n    permissionDecisionReason?: string;\n    updatedInput?: Record<string, unknown>;\n  };\n}\n\nexport type HookCallback = (\n  input: HookInput,\n  toolUseId: string | undefined,\n  options: { signal: AbortSignal }\n) => Promise<HookJSONOutput>;\n\nexport interface HookCallbackMatcher {\n  matcher?: string;\n  hooks: HookCallback[];\n}\n\n// Lazy import intelligence bridge to avoid circular dependencies\nlet intelligenceBridge: any = null;\n\nasync function getIntelligenceBridge() {\n  if (!intelligenceBridge) {\n    try {\n      intelligenceBridge = await import(\"../mcp/fastmcp/tools/hooks/intelligence-bridge.js\");\n    } catch (e) {\n      logger.warn('Intelligence bridge not available', { error: (e as Error).message });\n      return null;\n    }\n  }\n  return intelligenceBridge;\n}\n\n// Active trajectory tracking with TTL (5 minutes max)\nconst TRAJECTORY_TTL_MS = 5 * 60 * 1000;\nconst activeTrajectories = new Map<string, { trajectoryId: number; timestamp: number }>();\n\n// Cleanup stale trajectories periodically\nfunction cleanupStaleTrajectories(): void {\n  const now = Date.now();\n  for (const [key, value] of activeTrajectories.entries()) {\n    if (now - value.timestamp > TRAJECTORY_TTL_MS) {\n      activeTrajectories.delete(key);\n    }\n  }\n}\n\n// Run cleanup every 2 minutes\nsetInterval(cleanupStaleTrajectories, 2 * 60 * 1000).unref();\n\n/**\n * PreToolUse hook - Called before tool execution\n * Routes to best agent and starts trajectory tracking\n */\nexport const preToolUseHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'PreToolUse') return {};\n\n  const { tool_name, tool_input, session_id } = input as PreToolUseHookInput;\n\n  try {\n    const bridge = await getIntelligenceBridge();\n    if (!bridge) return {};\n\n    // Start trajectory for edit operations\n    if (['Edit', 'Write', 'Bash'].includes(tool_name)) {\n      const filePath = (tool_input as any)?.file_path || (tool_input as any)?.command || 'unknown';\n      const result = await bridge.beginTaskTrajectory(\n        `${tool_name}: ${filePath.substring(0, 100)}`,\n        'coder'\n      );\n\n      if (result.success && result.trajectoryId > 0) {\n        activeTrajectories.set(`${session_id}:${toolUseId}`, {\n          trajectoryId: result.trajectoryId,\n          timestamp: Date.now()\n        });\n        logger.debug('Trajectory started', { trajectoryId: result.trajectoryId, tool: tool_name });\n      }\n    }\n\n    return {};\n  } catch (error) {\n    logger.warn('PreToolUse hook error', { error: (error as Error).message });\n    return {};\n  }\n};\n\n/**\n * PostToolUse hook - Called after successful tool execution\n * Records patterns and ends trajectories\n */\nexport const postToolUseHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'PostToolUse') return {};\n\n  const { tool_name, tool_input, tool_response, session_id } = input as PostToolUseHookInput;\n\n  try {\n    const bridge = await getIntelligenceBridge();\n    if (!bridge) return {};\n\n    // End trajectory if one was started\n    const trajectoryKey = `${session_id}:${toolUseId}`;\n    const trajectoryEntry = activeTrajectories.get(trajectoryKey);\n\n    if (trajectoryEntry) {\n      await bridge.endTaskTrajectory(trajectoryEntry.trajectoryId, 'success');\n      activeTrajectories.delete(trajectoryKey);\n      logger.debug('Trajectory completed', { trajectoryId: trajectoryEntry.trajectoryId, tool: tool_name });\n    }\n\n    // Store successful pattern\n    if (['Edit', 'Write'].includes(tool_name)) {\n      const filePath = (tool_input as any)?.file_path || 'unknown';\n      await bridge.storePattern({\n        id: `sdk-${tool_name.toLowerCase()}-${Date.now()}`,\n        metadata: {\n          tool: tool_name,\n          file: filePath,\n          success: true,\n          timestamp: Date.now()\n        }\n      });\n    }\n\n    return {};\n  } catch (error) {\n    logger.warn('PostToolUse hook error', { error: (error as Error).message });\n    return {};\n  }\n};\n\n/**\n * PostToolUseFailure hook - Called when tool execution fails\n * Ends trajectories as failures\n */\nexport const postToolUseFailureHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'PostToolUseFailure') return {};\n\n  const { session_id } = input;\n\n  try {\n    const bridge = await getIntelligenceBridge();\n    if (!bridge) return {};\n\n    // End trajectory as failure\n    const trajectoryKey = `${session_id}:${toolUseId}`;\n    const trajectoryEntry = activeTrajectories.get(trajectoryKey);\n\n    if (trajectoryEntry) {\n      await bridge.endTaskTrajectory(trajectoryEntry.trajectoryId, 'failure');\n      activeTrajectories.delete(trajectoryKey);\n      logger.debug('Trajectory failed', { trajectoryId: trajectoryEntry.trajectoryId });\n    }\n\n    return {};\n  } catch (error) {\n    logger.warn('PostToolUseFailure hook error', { error: (error as Error).message });\n    return {};\n  }\n};\n\n/**\n * SessionStart hook - Called when session begins\n * Initializes intelligence layer\n */\nexport const sessionStartHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'SessionStart') return {};\n\n  const { source, session_id } = input as SessionStartHookInput;\n\n  try {\n    const bridge = await getIntelligenceBridge();\n    if (!bridge) {\n      return {\n        hookSpecificOutput: {\n          hookEventName: 'SessionStart',\n          additionalContext: 'Intelligence layer not available.'\n        }\n      };\n    }\n\n    const stats = await bridge.getIntelligenceStats();\n    const message = `RuVector Intelligence active. ` +\n      `Trajectories: ${stats.trajectoryCount}, ` +\n      `Features: ${stats.features?.join(', ') || 'none'}`;\n\n    logger.info('Session started', { sessionId: session_id, source, stats });\n\n    return {\n      hookSpecificOutput: {\n        hookEventName: 'SessionStart',\n        additionalContext: message\n      }\n    };\n  } catch (error) {\n    logger.warn('SessionStart hook error', { error: (error as Error).message });\n    return {};\n  }\n};\n\n/**\n * SessionEnd hook - Called when session ends\n * Persists learning data\n */\nexport const sessionEndHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'SessionEnd') return {};\n\n  const { reason, session_id } = input as SessionEndHookInput;\n\n  try {\n    const bridge = await getIntelligenceBridge();\n    if (!bridge) return {};\n\n    // Force learning cycle on session end\n    await bridge.forceLearningCycle();\n\n    logger.info('Session ended', { sessionId: session_id, reason });\n\n    return {};\n  } catch (error) {\n    logger.warn('SessionEnd hook error', { error: (error as Error).message });\n    return {};\n  }\n};\n\n/**\n * SubagentStart hook - Called when a subagent is spawned\n */\nexport const subagentStartHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'SubagentStart') return {};\n\n  const { agent_id, agent_type } = input as SubagentStartHookInput;\n\n  logger.info('Subagent started', { agentId: agent_id, agentType: agent_type });\n\n  return {};\n};\n\n/**\n * SubagentStop hook - Called when a subagent completes\n */\nexport const subagentStopHook: HookCallback = async (input, toolUseId, { signal }) => {\n  if (input.hook_event_name !== 'SubagentStop') return {};\n\n  logger.info('Subagent stopped');\n\n  return {};\n};\n\n/**\n * Get SDK hooks configuration\n * Returns hooks in the format expected by Claude Agent SDK query() options\n */\nexport function getSdkHooks(): Partial<Record<HookEvent, HookCallbackMatcher[]>> {\n  return {\n    PreToolUse: [{ hooks: [preToolUseHook] }],\n    PostToolUse: [{ hooks: [postToolUseHook] }],\n    PostToolUseFailure: [{ hooks: [postToolUseFailureHook] }],\n    SessionStart: [{ hooks: [sessionStartHook] }],\n    SessionEnd: [{ hooks: [sessionEndHook] }],\n    SubagentStart: [{ hooks: [subagentStartHook] }],\n    SubagentStop: [{ hooks: [subagentStopHook] }]\n  };\n}\n\n/**\n * Get filtered hooks for specific tools\n */\nexport function getToolSpecificHooks(toolMatcher: string): Partial<Record<HookEvent, HookCallbackMatcher[]>> {\n  return {\n    PreToolUse: [{ matcher: toolMatcher, hooks: [preToolUseHook] }],\n    PostToolUse: [{ matcher: toolMatcher, hooks: [postToolUseHook] }],\n    PostToolUseFailure: [{ matcher: toolMatcher, hooks: [postToolUseFailureHook] }]\n  };\n}\n"]}