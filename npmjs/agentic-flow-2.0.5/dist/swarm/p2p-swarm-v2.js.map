{"version":3,"file":"p2p-swarm-v2.js","sourceRoot":"","sources":["../../src/swarm/p2p-swarm-v2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * P2P Swarm v2 - Production Grade\n *\n * Fixes from code review:\n * 1. Two-layer key scheme (swarm envelope key + per-peer session keys)\n * 2. Ed25519 identity keys + X25519 ephemeral keys\n * 3. Message replay protection (nonces, counters, timestamps)\n * 4. Gun-based WebRTC signaling (no external PeerServer)\n * 5. IPFS CID pointers for large payloads\n * 6. Ed25519 signatures on all messages\n * 7. Relay health monitoring\n * 8. Task execution envelope with budgets\n */\n\nimport * as crypto from 'crypto';\nimport { logger } from '../utils/logger.js';\n\n//=============================================================================\n// CANONICAL SERIALIZATION\n//=============================================================================\n\n/**\n * Stable canonical JSON stringify\n *\n * Unlike JSON.stringify, this:\n * - Sorts object keys recursively (alphabetically)\n * - Produces identical output regardless of insertion order\n * - Is safe to use for signing and hashing\n */\nfunction stableStringify(obj: unknown): string {\n  if (obj === null || obj === undefined) {\n    return 'null';\n  }\n\n  if (typeof obj === 'boolean' || typeof obj === 'number') {\n    return JSON.stringify(obj);\n  }\n\n  if (typeof obj === 'string') {\n    return JSON.stringify(obj);\n  }\n\n  if (Array.isArray(obj)) {\n    const items = obj.map(item => stableStringify(item));\n    return '[' + items.join(',') + ']';\n  }\n\n  if (typeof obj === 'object') {\n    const keys = Object.keys(obj as Record<string, unknown>).sort();\n    const pairs = keys.map(key => {\n      const value = (obj as Record<string, unknown>)[key];\n      return JSON.stringify(key) + ':' + stableStringify(value);\n    });\n    return '{' + pairs.join(',') + '}';\n  }\n\n  // Fallback for other types\n  return JSON.stringify(obj);\n}\n\n//=============================================================================\n// CRYPTOGRAPHIC PRIMITIVES\n//=============================================================================\n\n/**\n * Identity and session key management\n *\n * Security fixes applied:\n * - Ed25519 uses crypto.sign(null, ...) - direct sign, not hash-then-sign\n * - Separate send counter (local) from receive counters (per-peer)\n * - Per-sender nonce tracking with timestamps for expiry\n * - X25519 ECDH + HKDF for real session key derivation\n */\nclass IdentityManager {\n  private identityKey: crypto.KeyPairKeyObjectResult;\n  private x25519Key: crypto.KeyPairKeyObjectResult;\n  private peerSessionKeys: Map<string, Buffer> = new Map();\n\n  // Per-sender nonce tracking: Map<senderId, Map<nonce, timestamp>>\n  private seenNonces: Map<string, Map<string, number>> = new Map();\n\n  // Separate send counter from receive counters\n  private localSendCounter: number = 0;\n  private recvCounters: Map<string, number> = new Map();\n\n  private maxNonceAge = 300000; // 5 minutes\n  private nonceCleanupInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    // Generate Ed25519 identity key pair (for signing)\n    this.identityKey = crypto.generateKeyPairSync('ed25519');\n\n    // Generate X25519 key pair (for key exchange)\n    this.x25519Key = crypto.generateKeyPairSync('x25519');\n\n    // Start periodic nonce cleanup\n    this.startNonceCleanup();\n  }\n\n  /**\n   * Get public identity key (PEM format for transport)\n   */\n  getPublicKey(): string {\n    return this.identityKey.publicKey.export({ type: 'spki', format: 'pem' }) as string;\n  }\n\n  /**\n   * Get X25519 public key for key exchange\n   */\n  getX25519PublicKey(): string {\n    return this.x25519Key.publicKey.export({ type: 'spki', format: 'pem' }) as string;\n  }\n\n  /**\n   * Sign data with Ed25519 identity key\n   * Ed25519 uses direct sign (no hash algorithm needed)\n   */\n  sign(data: string): string {\n    return crypto.sign(null, Buffer.from(data), this.identityKey.privateKey).toString('base64');\n  }\n\n  /**\n   * Verify Ed25519 signature from peer\n   */\n  verify(data: string, signature: string, peerPublicKey: string): boolean {\n    try {\n      const pubKey = crypto.createPublicKey({\n        key: peerPublicKey,\n        format: 'pem',\n        type: 'spki',\n      });\n      return crypto.verify(null, Buffer.from(data), pubKey, Buffer.from(signature, 'base64'));\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Derive session key with peer using real X25519 ECDH + HKDF\n   *\n   * Salt derivation: sha256(min(pubA, pubB) || max(pubA, pubB))\n   * - Stable per pair regardless of who initiates\n   * - High entropy from public key material\n   *\n   * Info: \"p2p-swarm-v2:${swarmId}:${peerId}\"\n   * - Prevents cross-swarm key reuse\n   * - Makes derived keys unique per pair and swarm\n   */\n  deriveSessionKey(peerX25519PubKey: string, peerId: string, swarmId: string = ''): Buffer {\n    // Check cache\n    const cacheKey = `${peerId}:${swarmId}`;\n    if (this.peerSessionKeys.has(cacheKey)) {\n      return this.peerSessionKeys.get(cacheKey)!;\n    }\n\n    try {\n      // Import peer's X25519 public key\n      const peerPubKey = crypto.createPublicKey({\n        key: peerX25519PubKey,\n        format: 'pem',\n        type: 'spki',\n      });\n\n      // Perform X25519 ECDH\n      const sharedSecret = crypto.diffieHellman({\n        privateKey: this.x25519Key.privateKey,\n        publicKey: peerPubKey,\n      });\n\n      // Get raw public keys for salt derivation\n      const myX25519Raw = this.x25519Key.publicKey.export({ type: 'spki', format: 'der' });\n      const peerX25519Raw = peerPubKey.export({ type: 'spki', format: 'der' });\n\n      // Salt = sha256(min(pubA, pubB) || max(pubA, pubB))\n      // Sort to ensure same salt regardless of who initiates\n      const [first, second] = Buffer.compare(myX25519Raw, peerX25519Raw) < 0\n        ? [myX25519Raw, peerX25519Raw]\n        : [peerX25519Raw, myX25519Raw];\n\n      const salt = crypto.createHash('sha256')\n        .update(first)\n        .update(second)\n        .digest();\n\n      // Info includes swarmId and peerId for domain separation\n      const info = Buffer.from(`p2p-swarm-v2:${swarmId}:${peerId}`);\n\n      // Derive session key using HKDF\n      const sessionKey = crypto.hkdfSync(\n        'sha256',\n        sharedSecret,    // IKM (input key material)\n        salt,            // Salt (from both parties' public keys)\n        info,            // Info (context + swarm + peer)\n        32               // Key length\n      );\n\n      this.peerSessionKeys.set(cacheKey, Buffer.from(sessionKey));\n      return Buffer.from(sessionKey);\n    } catch (error) {\n      // Fallback to hash-based derivation if X25519 fails\n      logger.warn('X25519 ECDH failed, using fallback', { peerId, error });\n      const fallbackKey = crypto.createHash('sha256')\n        .update(swarmId)\n        .update(peerId)\n        .update(this.getPublicKey())\n        .digest();\n      this.peerSessionKeys.set(cacheKey, fallbackKey);\n      return fallbackKey;\n    }\n  }\n\n  /**\n   * Generate cryptographically secure nonce\n   */\n  generateNonce(): string {\n    return crypto.randomBytes(16).toString('hex');\n  }\n\n  /**\n   * Check and record nonce with per-sender tracking\n   * Returns true if nonce is valid (not replayed, not expired)\n   */\n  checkNonce(nonce: string, timestamp: number, senderId: string): boolean {\n    const now = Date.now();\n\n    // Reject old messages (outside time window)\n    if (now - timestamp > this.maxNonceAge) {\n      return false;\n    }\n\n    // Reject future timestamps (with small tolerance for clock skew)\n    if (timestamp > now + 60000) { // 1 minute tolerance\n      return false;\n    }\n\n    // Get or create sender's nonce map\n    if (!this.seenNonces.has(senderId)) {\n      this.seenNonces.set(senderId, new Map());\n    }\n    const senderNonces = this.seenNonces.get(senderId)!;\n\n    // Reject replayed nonces from this sender\n    if (senderNonces.has(nonce)) {\n      return false;\n    }\n\n    // Record nonce with timestamp for expiry\n    senderNonces.set(nonce, timestamp);\n\n    return true;\n  }\n\n  /**\n   * Periodic cleanup of expired nonces\n   */\n  private startNonceCleanup(): void {\n    this.nonceCleanupInterval = setInterval(() => {\n      const now = Date.now();\n      const senderIds = Array.from(this.seenNonces.keys());\n      for (const senderId of senderIds) {\n        const nonceMap = this.seenNonces.get(senderId);\n        if (!nonceMap) continue;\n\n        const nonces = Array.from(nonceMap.entries());\n        for (const [nonce, timestamp] of nonces) {\n          if (now - timestamp > this.maxNonceAge) {\n            nonceMap.delete(nonce);\n          }\n        }\n        // Remove empty sender maps\n        if (nonceMap.size === 0) {\n          this.seenNonces.delete(senderId);\n        }\n      }\n    }, 60000); // Cleanup every minute\n  }\n\n  /**\n   * Get next send counter (monotonically increasing)\n   */\n  getNextSendCounter(): number {\n    return ++this.localSendCounter;\n  }\n\n  /**\n   * Validate received counter from peer (must be > last seen from that peer)\n   */\n  validateRecvCounter(peerId: string, counter: number): boolean {\n    const lastSeen = this.recvCounters.get(peerId) || 0;\n    if (counter <= lastSeen) {\n      return false;\n    }\n    this.recvCounters.set(peerId, counter);\n    return true;\n  }\n\n  /**\n   * Clear session key (for rotation)\n   */\n  rotateSessionKey(peerId: string): void {\n    this.peerSessionKeys.delete(peerId);\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    if (this.nonceCleanupInterval) {\n      clearInterval(this.nonceCleanupInterval);\n      this.nonceCleanupInterval = null;\n    }\n  }\n}\n\n/**\n * Encryption with proper GCM handling\n */\nclass CryptoV2 {\n  private algorithm = 'aes-256-gcm';\n\n  encrypt(data: string, key: Buffer): {\n    ciphertext: string;\n    iv: string;\n    tag: string;\n  } {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv(this.algorithm, key, iv) as crypto.CipherGCM;\n\n    let ciphertext = cipher.update(data, 'utf8', 'base64');\n    ciphertext += cipher.final('base64');\n\n    return {\n      ciphertext,\n      iv: iv.toString('base64'),\n      tag: cipher.getAuthTag().toString('base64'),\n    };\n  }\n\n  decrypt(ciphertext: string, key: Buffer, iv: string, tag: string): string | null {\n    try {\n      const decipher = crypto.createDecipheriv(\n        this.algorithm,\n        key,\n        Buffer.from(iv, 'base64')\n      ) as crypto.DecipherGCM;\n      decipher.setAuthTag(Buffer.from(tag, 'base64'));\n\n      let plaintext = decipher.update(ciphertext, 'base64', 'utf8');\n      plaintext += decipher.final('utf8');\n\n      return plaintext;\n    } catch {\n      return null;\n    }\n  }\n\n  hash(data: string | Buffer): string {\n    return crypto.createHash('sha256')\n      .update(typeof data === 'string' ? data : data)\n      .digest('hex');\n  }\n\n  generateCID(data: string | Buffer): string {\n    const hash = this.hash(data);\n    return `Qm${hash.slice(0, 44)}`;\n  }\n}\n\n//=============================================================================\n// MESSAGE TYPES AND ENVELOPES\n//=============================================================================\n\n/**\n * Signed message envelope for Gun pubsub\n *\n * Design rules:\n * - Gun = coordination bus (always use swarm envelope key)\n * - IPFS = artifact plane (content-addressed storage)\n * - WebRTC = private fast lane (can use per-peer session keys)\n *\n * Session keys are NOT used for Gun messages to avoid decryption\n * mismatch problems where only one receiver can decrypt.\n */\ninterface SignedEnvelope {\n  // Header (signed but not encrypted)\n  messageId: string;\n  topic: string;\n  timestamp: number;\n  senderId: string;\n  senderPubKey: string;        // Ed25519 identity key (for signature verification)\n  senderX25519Key: string;     // X25519 key (for direct channel key derivation only)\n  payloadHash: string;\n  nonce: string;\n  counter: number;             // Sender's monotonic counter\n  signature: string;\n\n  // Encrypted payload (always with swarm key for Gun)\n  encrypted: {\n    ciphertext: string;\n    iv: string;\n    tag: string;\n  };\n}\n\n/**\n * Task execution envelope\n */\ninterface TaskEnvelope {\n  taskId: string;\n  moduleCID: string;       // WASM module on IPFS\n  entrypoint: string;\n  inputCID: string;        // Input data on IPFS\n  outputSchemaHash: string;\n\n  // Resource budgets\n  budgets: {\n    fuelLimit: number;     // Wasmtime fuel\n    memoryMB: number;      // Max memory\n    timeoutMs: number;     // Max execution time\n  };\n\n  // Metadata\n  requester: string;\n  deadline: number;\n  priority: number;\n}\n\n/**\n * Task result receipt with full execution binding\n * The signature covers ALL fields to prevent tampering\n *\n * Includes binding to the original TaskEnvelope for complete traceability\n */\ninterface TaskReceipt {\n  taskId: string;\n  executor: string;\n  executorPubKey: string;      // Ed25519 key of executor\n  resultCID: string;\n  status: 'success' | 'error' | 'timeout' | 'oom';\n\n  // Resource usage\n  fuelUsed: number;\n  memoryPeakMB: number;\n  executionMs: number;\n\n  // Execution binding (proves this receipt is for this specific execution)\n  inputHash: string;           // Hash of input data\n  outputHash: string;          // Hash of output data\n  moduleHash: string;          // Hash of WASM module\n  startTimestamp: number;\n  endTimestamp: number;\n\n  // TaskEnvelope binding (proves this receipt matches the original task)\n  moduleCID: string;           // From TaskEnvelope\n  inputCID: string;            // From TaskEnvelope\n  entrypoint: string;          // From TaskEnvelope\n  outputSchemaHash: string;    // From TaskEnvelope\n  taskEnvelopeHash: string;    // Hash of entire original TaskEnvelope\n\n  // Signature covers all fields above\n  signature: string;\n}\n\n/**\n * Learning artifact pointer (small, goes to Gun)\n */\ninterface ArtifactPointer {\n  type: 'q_table' | 'memory_vectors' | 'model_weights' | 'trajectory';\n  agentId: string;\n  cid: string;\n  version: number;\n  schemaHash: string;\n  dimensions: string;\n  checksum: string;\n  timestamp: number;\n  signature: string;\n}\n\n//=============================================================================\n// RELAY MANAGEMENT\n//=============================================================================\n\n/**\n * Relay health tracker\n */\nclass RelayManager {\n  private relays: Map<string, {\n    url: string;\n    healthy: boolean;\n    lastCheck: number;\n    latencyMs: number;\n    failures: number;\n  }> = new Map();\n\n  private workingRelays: string[] = [];\n\n  static readonly BOOTSTRAP_RELAYS = [\n    'https://gun-manhattan.herokuapp.com/gun',\n    'https://gun-us.herokuapp.com/gun',\n    'https://gun-eu.herokuapp.com/gun',\n  ];\n\n  constructor(customRelays?: string[]) {\n    const relayList = customRelays || RelayManager.BOOTSTRAP_RELAYS;\n    for (const url of relayList) {\n      this.relays.set(url, {\n        url,\n        healthy: true, // Assume healthy initially\n        lastCheck: 0,\n        latencyMs: 0,\n        failures: 0,\n      });\n    }\n    this.workingRelays = relayList;\n  }\n\n  /**\n   * Get working relays\n   */\n  getWorkingRelays(): string[] {\n    return this.workingRelays.filter(url => {\n      const relay = this.relays.get(url);\n      return relay && relay.healthy;\n    });\n  }\n\n  /**\n   * Mark relay as failed\n   */\n  markFailed(url: string): void {\n    const relay = this.relays.get(url);\n    if (relay) {\n      relay.failures++;\n      if (relay.failures >= 3) {\n        relay.healthy = false;\n        logger.warn('Relay marked unhealthy', { url, failures: relay.failures });\n      }\n    }\n  }\n\n  /**\n   * Mark relay as successful\n   */\n  markSuccess(url: string, latencyMs: number): void {\n    const relay = this.relays.get(url);\n    if (relay) {\n      relay.healthy = true;\n      relay.latencyMs = latencyMs;\n      relay.failures = 0;\n      relay.lastCheck = Date.now();\n    }\n  }\n\n  /**\n   * Add new relay\n   */\n  addRelay(url: string): void {\n    if (!this.relays.has(url)) {\n      this.relays.set(url, {\n        url,\n        healthy: true,\n        lastCheck: 0,\n        latencyMs: 0,\n        failures: 0,\n      });\n      this.workingRelays.push(url);\n    }\n  }\n\n  /**\n   * Get health metrics\n   */\n  getMetrics(): {\n    total: number;\n    healthy: number;\n    avgLatency: number;\n  } {\n    const healthyRelays = Array.from(this.relays.values()).filter(r => r.healthy);\n    const avgLatency = healthyRelays.length > 0\n      ? healthyRelays.reduce((sum, r) => sum + r.latencyMs, 0) / healthyRelays.length\n      : 0;\n\n    return {\n      total: this.relays.size,\n      healthy: healthyRelays.length,\n      avgLatency,\n    };\n  }\n\n  /**\n   * Persist working set\n   */\n  exportWorkingSet(): string[] {\n    return this.getWorkingRelays();\n  }\n\n  /**\n   * Import working set\n   */\n  importWorkingSet(relays: string[]): void {\n    for (const url of relays) {\n      this.addRelay(url);\n    }\n  }\n}\n\n//=============================================================================\n// IPFS ARTIFACT STORAGE\n//=============================================================================\n\n/**\n * IPFS artifact manager (CID-based storage)\n *\n * IMPORTANT CID LIMITATION:\n * The current generateCID creates a simplified hash-based identifier (Qm prefix).\n * This is NOT a real IPFS CID and will NOT interop with:\n * - Real IPFS gateways\n * - Pinning services (Pinata, web3.storage, Filebase)\n * - Content routing\n *\n * For production, you need one of:\n * A) Real IPFS client: add bytes to IPFS node, take returned CID\n * B) Multiformats library: create CIDv1 from raw bytes offline\n *\n * The current implementation works for local coordination and can be\n * upgraded to real IPFS when needed.\n *\n * Gateway fetch is DISABLED by default because our fake CIDs won't work.\n * Enable only when using real multiformats CIDv1 generation.\n */\nclass ArtifactStore {\n  private localCache: Map<string, Buffer> = new Map();\n  private crypto: CryptoV2;\n  private maxCacheSize = 100 * 1024 * 1024; // 100MB\n  private currentCacheSize = 0;\n  private maxArtifactSize = 10 * 1024 * 1024; // 10MB max per artifact\n\n  // DISABLED: Gateway fetch only works with real IPFS CIDs\n  private enableGatewayFetch = false;\n\n  static readonly CHUNK_SIZE = 256 * 1024; // 256KB chunks\n\n  // Public IPFS gateways for fetching (when real CIDs are used)\n  static readonly IPFS_GATEWAYS = [\n    'https://ipfs.io/ipfs/',\n    'https://dweb.link/ipfs/',\n    'https://cloudflare-ipfs.com/ipfs/',\n    'https://gateway.pinata.cloud/ipfs/',\n  ];\n\n  constructor(enableGatewayFetch: boolean = false) {\n    this.crypto = new CryptoV2();\n    this.enableGatewayFetch = enableGatewayFetch;\n  }\n\n  /**\n   * Store artifact and get CID\n   */\n  async store(data: Buffer | string, compress: boolean = true): Promise<{\n    cid: string;\n    size: number;\n    chunks: number;\n  }> {\n    const buffer = typeof data === 'string' ? Buffer.from(data) : data;\n\n    // Enforce size limit\n    if (buffer.length > this.maxArtifactSize) {\n      throw new Error(`Artifact exceeds max size: ${buffer.length} > ${this.maxArtifactSize}`);\n    }\n\n    // Optional compression (in production: use zstd or lz4)\n    const toStore = compress ? buffer : buffer; // Placeholder for compression\n\n    // Generate CID (NOTE: simplified, not real IPFS CID)\n    const cid = this.crypto.generateCID(toStore);\n\n    // Store locally\n    this.cacheStore(cid, toStore);\n\n    // Calculate chunks\n    const chunks = Math.ceil(toStore.length / ArtifactStore.CHUNK_SIZE);\n\n    return {\n      cid,\n      size: toStore.length,\n      chunks,\n    };\n  }\n\n  /**\n   * Retrieve artifact by CID\n   *\n   * Strategy:\n   * 1. Check local cache\n   * 2. If enableGatewayFetch=true AND CID is real (bafy prefix), try gateways\n   * 3. Otherwise return null (local-only mode)\n   *\n   * Gateway fetch is DISABLED by default because our simplified CIDs\n   * are not real IPFS CIDs and won't work with gateways.\n   */\n  async retrieve(cid: string): Promise<Buffer | null> {\n    // Check local cache\n    if (this.localCache.has(cid)) {\n      return this.localCache.get(cid)!;\n    }\n\n    // Gateway fetch disabled - local cache only\n    if (!this.enableGatewayFetch) {\n      return null;\n    }\n\n    // Only attempt gateway fetch for real CIDv1 (bafy prefix)\n    // Our fake Qm CIDs will NOT work with gateways\n    if (!cid.startsWith('bafy')) {\n      logger.debug('Gateway fetch skipped: not a real CIDv1', { cid });\n      return null;\n    }\n\n    // Try fetching from gateways for real IPFS CIDs\n    for (const gateway of ArtifactStore.IPFS_GATEWAYS) {\n      try {\n        const response = await fetch(`${gateway}${cid}`, {\n          signal: AbortSignal.timeout(10000), // 10 second timeout\n        });\n\n        if (response.ok) {\n          const data = Buffer.from(await response.arrayBuffer());\n\n          // Verify size\n          if (data.length > this.maxArtifactSize) {\n            logger.warn('Fetched artifact exceeds max size', { cid, size: data.length });\n            continue;\n          }\n\n          // TODO: Verify CID matches content using multiformats\n          // For now, we trust the gateway (risky, but we're gated by real CID requirement)\n\n          // Store in cache and return\n          this.cacheStore(cid, data);\n          return data;\n        }\n      } catch (error) {\n        // Try next gateway\n        logger.debug('Gateway fetch failed', { gateway, cid, error });\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Enable gateway fetch (only when using real IPFS CIDs)\n   */\n  setEnableGatewayFetch(enable: boolean): void {\n    this.enableGatewayFetch = enable;\n  }\n\n  /**\n   * Store in local cache with eviction\n   */\n  private cacheStore(cid: string, data: Buffer): void {\n    // Evict if necessary\n    while (this.currentCacheSize + data.length > this.maxCacheSize) {\n      const firstKey = this.localCache.keys().next().value;\n      if (firstKey) {\n        const size = this.localCache.get(firstKey)?.length || 0;\n        this.localCache.delete(firstKey);\n        this.currentCacheSize -= size;\n      } else {\n        break;\n      }\n    }\n\n    this.localCache.set(cid, data);\n    this.currentCacheSize += data.length;\n  }\n\n  /**\n   * Create artifact pointer for Gun\n   * Uses stableStringify for deterministic signing\n   */\n  createPointer(\n    type: ArtifactPointer['type'],\n    agentId: string,\n    cid: string,\n    dimensions: string,\n    identity: IdentityManager\n  ): ArtifactPointer {\n    const data = this.localCache.get(cid);\n    const checksum = data ? this.crypto.hash(data).slice(0, 16) : '';\n\n    const pointer: Omit<ArtifactPointer, 'signature'> = {\n      type,\n      agentId,\n      cid,\n      version: 1,\n      schemaHash: this.crypto.hash(type).slice(0, 8),\n      dimensions,\n      checksum,\n      timestamp: Date.now(),\n    };\n\n    // Use stableStringify for deterministic signing\n    const signature = identity.sign(stableStringify(pointer));\n\n    return { ...pointer, signature };\n  }\n}\n\n//=============================================================================\n// MAIN P2P SWARM V2\n//=============================================================================\n\n/**\n * Production-grade P2P Swarm Coordinator\n */\nexport class P2PSwarmV2 {\n  private identity: IdentityManager;\n  private crypto: CryptoV2;\n  private relayManager: RelayManager;\n  private artifactStore: ArtifactStore;\n\n  private swarmKey: Buffer;\n  private swarmId: string;\n  private agentId: string;\n\n  private gun: any = null;\n  private swarmNode: any = null;\n  private connected: boolean = false;\n\n  private messageHandlers: Map<string, (data: any, from: string) => void> = new Map();\n  private pendingOffers: Map<string, any> = new Map();\n\n  // Member registry: source of truth for identity binding\n  // NEVER trust keys from envelopes - always resolve from registry\n  private memberRegistry: Map<string, {\n    agentId: string;\n    publicKey: string;          // Ed25519 identity key\n    x25519PublicKey: string;    // X25519 key exchange key\n    capabilities: string[];\n    joinedAt: number;\n    verified: boolean;          // Has registration signature been verified?\n    lastSeen: number;           // Heartbeat timestamp\n  }> = new Map();\n\n  // Heartbeat and task executor state\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private taskExecutorActive: boolean = false;\n  private claimedTasks: Set<string> = new Set();\n  private readonly HEARTBEAT_INTERVAL_MS = 20000; // 20 seconds\n  private readonly MEMBER_TIMEOUT_MS = 60000; // 60 seconds without heartbeat = offline\n\n  // Negative cache for failed member lookups (prevents spam)\n  private negativeMemberCache: Map<string, number> = new Map();\n  private readonly NEGATIVE_CACHE_TTL_MS = 30000; // 30 seconds\n\n  // Task claim conflict resolution\n  private readonly CLAIM_TTL_MS = 45000; // 45 seconds - claims older than this can be overwritten\n\n  constructor(agentId: string, swarmKey?: string) {\n    this.identity = new IdentityManager();\n    this.crypto = new CryptoV2();\n    this.relayManager = new RelayManager();\n    this.artifactStore = new ArtifactStore();\n\n    this.agentId = agentId;\n    this.swarmKey = swarmKey\n      ? Buffer.from(swarmKey, 'base64')\n      : crypto.randomBytes(32);\n    this.swarmId = this.crypto.hash(this.swarmKey.toString('base64')).slice(0, 16);\n  }\n\n  /**\n   * Connect to Gun relays\n   *\n   * Starts autonomy features:\n   * - Membership watcher (subscribe to members, verify registrations)\n   * - Heartbeat publishing (every 20 seconds)\n   * - Task executor loop (optional, enable with startTaskExecutor())\n   */\n  async connect(): Promise<boolean> {\n    try {\n      const Gun = (await import('gun')).default;\n      const relays = this.relayManager.getWorkingRelays();\n\n      this.gun = Gun(relays);\n      this.swarmNode = this.gun.get(`swarm-v2-${this.swarmId}`);\n\n      // Register self\n      await this.registerSelf();\n\n      // Subscribe to signaling for WebRTC\n      this.subscribeToSignaling();\n\n      // Start membership watcher\n      this.startMembershipWatcher();\n\n      // IMPORTANT: Set connected BEFORE heartbeat to ensure first heartbeat publishes\n      this.connected = true;\n\n      // Start heartbeat publishing\n      this.startHeartbeat();\n\n      logger.info('P2P Swarm V2 connected', {\n        swarmId: this.swarmId,\n        agentId: this.agentId,\n        relays: relays.length,\n      });\n\n      return true;\n    } catch (error) {\n      logger.error('Failed to connect', { error });\n      return false;\n    }\n  }\n\n  /**\n   * Register self with public key and X25519 key\n   * Uses canonical serialization for signature\n   * Field order must match verifyMemberRegistration\n   */\n  private async registerSelf(): Promise<void> {\n    if (!this.swarmNode) return;\n\n    const joinedAt = Date.now();\n    const capabilities = ['coordinator', 'executor'];\n\n    // Data to sign (must match verifyMemberRegistration order)\n    const dataToSign = {\n      agentId: this.agentId,\n      capabilities,\n      joinedAt,\n      publicKey: this.identity.getPublicKey(),\n      x25519PublicKey: this.identity.getX25519PublicKey(),\n    };\n\n    // Sign using canonical serialization\n    const signature = this.identity.sign(stableStringify(dataToSign));\n\n    // Full registration record\n    const registration = {\n      ...dataToSign,\n      signature,\n    };\n\n    this.swarmNode.get('members').get(this.agentId).put(registration);\n\n    // Add self to local registry\n    const now = Date.now();\n    this.memberRegistry.set(this.agentId, {\n      ...dataToSign,\n      verified: true, // We trust ourselves\n      lastSeen: now,\n    });\n  }\n\n  /**\n   * Verified member entry type\n   */\n  private static readonly MEMBER_REQUIRED_FIELDS = ['agentId', 'publicKey', 'x25519PublicKey', 'capabilities', 'joinedAt', 'signature'] as const;\n\n  /**\n   * Verify and cache a member registration from Gun\n   * STRICT: Requires all fields including x25519PublicKey\n   * Returns the verified member or null if invalid\n   */\n  private verifyMemberRegistration(registration: any): {\n    agentId: string;\n    publicKey: string;\n    x25519PublicKey: string;\n    capabilities: string[];\n    joinedAt: number;\n    verified: boolean;\n    lastSeen: number;\n  } | null {\n    // STRICT: Require all fields\n    if (!registration) return null;\n\n    for (const field of P2PSwarmV2.MEMBER_REQUIRED_FIELDS) {\n      if (registration[field] === undefined || registration[field] === null) {\n        logger.debug('Member registration missing required field', { field, agentId: registration.agentId });\n        return null;\n      }\n    }\n\n    // Validate types\n    if (typeof registration.agentId !== 'string' || registration.agentId.length === 0) return null;\n    if (typeof registration.publicKey !== 'string' || registration.publicKey.length === 0) return null;\n    if (typeof registration.x25519PublicKey !== 'string' || registration.x25519PublicKey.length === 0) return null;\n    if (!Array.isArray(registration.capabilities)) return null;\n    if (typeof registration.joinedAt !== 'number' || registration.joinedAt <= 0) return null;\n\n    // Reconstruct the signed data (must match registration order)\n    const dataToVerify = {\n      agentId: registration.agentId,\n      capabilities: registration.capabilities,\n      joinedAt: registration.joinedAt,\n      publicKey: registration.publicKey,\n      x25519PublicKey: registration.x25519PublicKey,\n    };\n\n    // Verify signature using the key in the registration\n    if (!this.identity.verify(stableStringify(dataToVerify), registration.signature, registration.publicKey)) {\n      logger.warn('Member registration signature invalid', { agentId: registration.agentId });\n      return null;\n    }\n\n    return {\n      agentId: registration.agentId,\n      publicKey: registration.publicKey,\n      x25519PublicKey: registration.x25519PublicKey,\n      capabilities: registration.capabilities,\n      joinedAt: registration.joinedAt,\n      verified: true,\n      lastSeen: Date.now(), // Set initial lastSeen to now\n    };\n  }\n\n  /**\n   * Resolve full verified member from the registry\n   * Returns the complete member entry (with both Ed25519 and X25519 keys)\n   * Returns null if member not found or not verified\n   *\n   * Uses negative cache to prevent spam from repeated lookups of unknown agents\n   */\n  private async resolveMember(agentId: string): Promise<{\n    agentId: string;\n    publicKey: string;\n    x25519PublicKey: string;\n    capabilities: string[];\n    joinedAt: number;\n    verified: boolean;\n    lastSeen: number;\n  } | null> {\n    // Check local cache first\n    const cached = this.memberRegistry.get(agentId);\n    if (cached && cached.verified) {\n      return cached;\n    }\n\n    // Check negative cache (prevents spam from repeated lookups)\n    const negativeCacheTime = this.negativeMemberCache.get(agentId);\n    if (negativeCacheTime && Date.now() - negativeCacheTime < this.NEGATIVE_CACHE_TTL_MS) {\n      return null; // Still in negative cache window\n    }\n\n    // Fetch from Gun and verify\n    if (!this.swarmNode) return null;\n\n    return new Promise((resolve) => {\n      let resolved = false;\n\n      this.swarmNode.get('members').get(agentId).once((registration: any) => {\n        if (resolved) return;\n        resolved = true;\n\n        if (!registration) {\n          // Add to negative cache\n          this.negativeMemberCache.set(agentId, Date.now());\n          resolve(null);\n          return;\n        }\n\n        const verified = this.verifyMemberRegistration(registration);\n        if (verified) {\n          this.memberRegistry.set(agentId, verified);\n          // Remove from negative cache if it was there\n          this.negativeMemberCache.delete(agentId);\n          resolve(verified);\n        } else {\n          // Add to negative cache\n          this.negativeMemberCache.set(agentId, Date.now());\n          resolve(null);\n        }\n      });\n\n      // Timeout after 5 seconds\n      setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          // Add to negative cache on timeout\n          this.negativeMemberCache.set(agentId, Date.now());\n          resolve(null);\n        }\n      }, 5000);\n    });\n  }\n\n  /**\n   * Convenience: Resolve just the Ed25519 public key\n   */\n  private async resolveMemberKey(agentId: string): Promise<string | null> {\n    const member = await this.resolveMember(agentId);\n    return member?.publicKey || null;\n  }\n\n  /**\n   * Subscribe to WebRTC signaling (Gun-based, no PeerServer needed)\n   * SECURITY: Verifies signatures using registry key, not envelope key\n   */\n  private subscribeToSignaling(): void {\n    if (!this.swarmNode) return;\n\n    // Listen for signals addressed to us\n    this.swarmNode.get('signaling').get(this.agentId).map().on(async (signal: any, key: string) => {\n      if (!signal || signal.from === this.agentId) return;\n\n      // Filter expired signals\n      if (signal.expiresAt && Date.now() > signal.expiresAt) {\n        return;\n      }\n\n      // Filter old signals (more than 2 minutes)\n      if (signal.timestamp && Date.now() - signal.timestamp > 120000) {\n        return;\n      }\n\n      // STRICT IDENTITY: Resolve sender's key from registry\n      const registeredKey = await this.resolveMemberKey(signal.from);\n      if (!registeredKey) {\n        logger.debug('Rejected signaling: sender not in registry', { from: signal.from });\n        return;\n      }\n\n      // Verify using REGISTRY key, not signal.senderPubKey\n      const canonical = stableStringify({\n        expiresAt: signal.expiresAt,\n        from: signal.from,\n        payloadHash: signal.payloadHash,\n        timestamp: signal.timestamp,\n        to: signal.to,\n        type: signal.type,\n      });\n\n      if (!this.identity.verify(canonical, signal.signature, registeredKey)) {\n        logger.debug('Rejected signaling: invalid signature', { from: signal.from, type: signal.type });\n        return;\n      }\n\n      // Verify payload hash\n      if (signal.payload && this.crypto.hash(signal.payload) !== signal.payloadHash) {\n        logger.debug('Rejected signaling: payload hash mismatch', { from: signal.from });\n        return;\n      }\n\n      if (signal.type === 'offer') {\n        this.handleOffer(signal);\n      } else if (signal.type === 'answer') {\n        this.handleAnswer(signal);\n      } else if (signal.type === 'ice') {\n        this.handleICE(signal);\n      }\n    });\n  }\n\n  /**\n   * Handle incoming WebRTC offer (via Gun signaling)\n   */\n  private handleOffer(signal: any): void {\n    logger.debug('Received WebRTC offer via Gun', { from: signal.from });\n    // In production: create RTCPeerConnection, set remote description, create answer\n    // For now, just log\n  }\n\n  /**\n   * Handle incoming WebRTC answer\n   */\n  private handleAnswer(signal: any): void {\n    logger.debug('Received WebRTC answer via Gun', { from: signal.from });\n  }\n\n  /**\n   * Handle incoming ICE candidate\n   */\n  private handleICE(signal: any): void {\n    logger.debug('Received ICE candidate via Gun', { from: signal.from });\n  }\n\n  /**\n   * Create canonical signaling message and signature\n   * Uses stableStringify for deterministic serialization\n   */\n  private createCanonicalSignal(\n    type: 'offer' | 'answer' | 'ice',\n    targetAgentId: string,\n    payload: string,\n    ttl: number\n  ): {\n    canonical: string;\n    signal: any;\n  } {\n    const timestamp = Date.now();\n    const expiresAt = timestamp + ttl;\n    const payloadHash = this.crypto.hash(payload);\n\n    // Canonical object for signing (stableStringify ensures sorted keys)\n    const canonicalObj = {\n      expiresAt,\n      from: this.agentId,\n      payloadHash,\n      timestamp,\n      to: targetAgentId,\n      type,\n    };\n    const canonical = stableStringify(canonicalObj);\n\n    const signature = this.identity.sign(canonical);\n\n    return {\n      canonical,\n      signal: {\n        type,\n        from: this.agentId,\n        to: targetAgentId,\n        payload,\n        payloadHash,\n        timestamp,\n        expiresAt,\n        senderPubKey: this.identity.getPublicKey(),\n        signature,\n      },\n    };\n  }\n\n  // NOTE: verifyCanonicalSignal was removed as redundant.\n  // Signal verification now happens in subscribeToSignaling using\n  // registry-based identity binding, which is both safer and consistent.\n\n  /**\n   * Send WebRTC offer via Gun (no PeerServer needed)\n   * Uses canonical signature for verification\n   */\n  async sendOffer(targetAgentId: string, offer: any): Promise<void> {\n    if (!this.swarmNode) return;\n\n    const payload = JSON.stringify(offer).slice(0, 10000); // Cap size at 10KB\n    const ttl = 60000; // 1 minute TTL\n\n    const { signal } = this.createCanonicalSignal('offer', targetAgentId, payload, ttl);\n    const signalId = this.crypto.hash(`${this.agentId}:${targetAgentId}:${signal.timestamp}`).slice(0, 12);\n\n    this.swarmNode.get('signaling').get(targetAgentId).get(signalId).put(signal);\n\n    // Schedule cleanup (best effort, expiry filter does real work)\n    setTimeout(() => {\n      this.swarmNode?.get('signaling').get(targetAgentId).get(signalId).put(null);\n    }, ttl);\n  }\n\n  /**\n   * Send WebRTC answer via Gun\n   */\n  async sendAnswer(targetAgentId: string, answer: any): Promise<void> {\n    if (!this.swarmNode) return;\n\n    const payload = JSON.stringify(answer).slice(0, 10000);\n    const ttl = 60000;\n\n    const { signal } = this.createCanonicalSignal('answer', targetAgentId, payload, ttl);\n    const signalId = this.crypto.hash(`answer:${this.agentId}:${targetAgentId}:${signal.timestamp}`).slice(0, 12);\n\n    this.swarmNode.get('signaling').get(targetAgentId).get(signalId).put(signal);\n\n    setTimeout(() => {\n      this.swarmNode?.get('signaling').get(targetAgentId).get(signalId).put(null);\n    }, ttl);\n  }\n\n  /**\n   * Send ICE candidate via Gun\n   */\n  async sendICE(targetAgentId: string, candidate: any): Promise<void> {\n    if (!this.swarmNode) return;\n\n    const payload = JSON.stringify(candidate).slice(0, 2000); // ICE candidates are small\n    const ttl = 30000; // 30 second TTL\n\n    const { signal } = this.createCanonicalSignal('ice', targetAgentId, payload, ttl);\n    const signalId = this.crypto.hash(`ice:${this.agentId}:${signal.timestamp}`).slice(0, 12);\n\n    this.swarmNode.get('signaling').get(targetAgentId).get(signalId).put(signal);\n\n    setTimeout(() => {\n      this.swarmNode?.get('signaling').get(targetAgentId).get(signalId).put(null);\n    }, ttl);\n  }\n\n  /**\n   * Publish signed and encrypted message\n   *\n   * Gun messages ALWAYS use swarm envelope key (not session keys)\n   * This ensures all swarm members can decrypt and process messages.\n   * Uses canonical serialization for signature stability.\n   */\n  async publish(topic: string, payload: any): Promise<string> {\n    const nonce = this.identity.generateNonce();\n    const counter = this.identity.getNextSendCounter(); // Use local send counter\n    const timestamp = Date.now();\n    const payloadStr = stableStringify(payload);\n    const payloadHash = this.crypto.hash(payloadStr);\n    const messageId = this.crypto.hash(`${topic}:${nonce}:${timestamp}`).slice(0, 16);\n\n    // Create signature over header fields using CANONICAL serialization\n    // Keys are sorted alphabetically for deterministic output\n    const headerToSign = {\n      counter,\n      messageId,\n      nonce,\n      payloadHash,\n      senderId: this.agentId,\n      senderX25519Key: this.identity.getX25519PublicKey(),\n      timestamp,\n      topic,\n    };\n    const signature = this.identity.sign(stableStringify(headerToSign));\n\n    // Encrypt payload with swarm key (ALWAYS for Gun messages)\n    const encrypted = this.crypto.encrypt(payloadStr, this.swarmKey);\n\n    const envelope: SignedEnvelope = {\n      messageId,\n      topic,\n      timestamp,\n      senderId: this.agentId,\n      senderPubKey: this.identity.getPublicKey(),\n      senderX25519Key: this.identity.getX25519PublicKey(),\n      payloadHash,\n      nonce,\n      counter,\n      signature,\n      encrypted,\n    };\n\n    // Publish to Gun\n    if (this.swarmNode) {\n      this.swarmNode.get('messages').get(topic).get(messageId).put(envelope);\n    }\n\n    return messageId;\n  }\n\n  /**\n   * Subscribe to topic with strict identity verification\n   *\n   * SECURITY: Never trust keys from envelopes. Always resolve from registry.\n   *\n   * Verification steps:\n   * 1. Check nonce and timestamp (replay protection)\n   * 2. Check counter (ordering)\n   * 3. Resolve sender's public key from verified member registry\n   * 4. Reject if envelope key differs from registry key\n   * 5. Verify signature using registry key\n   * 6. Decrypt with swarm key\n   * 7. Verify payload hash\n   */\n  subscribe(topic: string, callback: (data: any, from: string) => void): void {\n    this.messageHandlers.set(topic, callback);\n\n    if (!this.swarmNode) return;\n\n    this.swarmNode.get('messages').get(topic).map().on(async (envelope: SignedEnvelope, key: string) => {\n      if (!envelope || !envelope.encrypted) return;\n\n      // Ignore own messages\n      if (envelope.senderId === this.agentId) return;\n\n      // Validate timestamp and nonce (per-sender replay protection)\n      if (!this.identity.checkNonce(envelope.nonce, envelope.timestamp, envelope.senderId)) {\n        logger.debug('Rejected: replay or expired', { messageId: envelope.messageId });\n        return;\n      }\n\n      // Validate counter (must be > last seen from this sender)\n      if (!this.identity.validateRecvCounter(envelope.senderId, envelope.counter)) {\n        logger.debug('Rejected: invalid counter', { messageId: envelope.messageId });\n        return;\n      }\n\n      // STRICT IDENTITY: Resolve public key from verified registry\n      const registeredKey = await this.resolveMemberKey(envelope.senderId);\n      if (!registeredKey) {\n        logger.debug('Rejected: sender not in verified registry', {\n          messageId: envelope.messageId,\n          senderId: envelope.senderId,\n        });\n        return;\n      }\n\n      // Reject if envelope key differs from registry key\n      if (registeredKey !== envelope.senderPubKey) {\n        logger.warn('Rejected: envelope key differs from registry', {\n          messageId: envelope.messageId,\n          senderId: envelope.senderId,\n        });\n        return;\n      }\n\n      // Verify signature using REGISTRY key (not envelope key)\n      const headerToVerify = {\n        counter: envelope.counter,\n        messageId: envelope.messageId,\n        nonce: envelope.nonce,\n        payloadHash: envelope.payloadHash,\n        senderId: envelope.senderId,\n        senderX25519Key: envelope.senderX25519Key,\n        timestamp: envelope.timestamp,\n        topic: envelope.topic,\n      };\n\n      if (!this.identity.verify(stableStringify(headerToVerify), envelope.signature, registeredKey)) {\n        logger.warn('Rejected: invalid signature', { messageId: envelope.messageId });\n        return;\n      }\n\n      // Decrypt payload with swarm key (Gun messages always use swarm key)\n      const decrypted = this.crypto.decrypt(\n        envelope.encrypted.ciphertext,\n        this.swarmKey,\n        envelope.encrypted.iv,\n        envelope.encrypted.tag\n      );\n\n      if (!decrypted) {\n        logger.warn('Rejected: decryption failed', { messageId: envelope.messageId });\n        return;\n      }\n\n      // Verify payload hash\n      if (this.crypto.hash(decrypted) !== envelope.payloadHash) {\n        logger.warn('Rejected: payload hash mismatch', { messageId: envelope.messageId });\n        return;\n      }\n\n      // Dispatch to handler\n      const handler = this.messageHandlers.get(topic);\n      if (handler) {\n        handler(JSON.parse(decrypted), envelope.senderId);\n      }\n    });\n  }\n\n  /**\n   * Store Q-table and publish pointer\n   */\n  async syncQTable(qTable: number[][]): Promise<ArtifactPointer> {\n    // Store actual data\n    const data = JSON.stringify(qTable);\n    const { cid, size, chunks } = await this.artifactStore.store(data);\n\n    // Create pointer\n    const dimensions = `${qTable.length}x${qTable[0]?.length || 0}`;\n    const pointer = this.artifactStore.createPointer(\n      'q_table',\n      this.agentId,\n      cid,\n      dimensions,\n      this.identity\n    );\n\n    // Publish pointer to Gun (small, metadata only)\n    await this.publish('artifacts', pointer);\n\n    logger.debug('Q-table synced', { cid, size, chunks });\n\n    return pointer;\n  }\n\n  /**\n   * Store memory vectors and publish pointer\n   */\n  async syncMemory(vectors: number[][], namespace: string): Promise<ArtifactPointer> {\n    const data = JSON.stringify({ vectors, namespace });\n    const { cid, size, chunks } = await this.artifactStore.store(data);\n\n    const dimensions = `${vectors.length}x${vectors[0]?.length || 0}`;\n    const pointer = this.artifactStore.createPointer(\n      'memory_vectors',\n      this.agentId,\n      cid,\n      dimensions,\n      this.identity\n    );\n\n    await this.publish('artifacts', pointer);\n\n    logger.debug('Memory synced', { cid, size, chunks, namespace });\n\n    return pointer;\n  }\n\n  /**\n   * Submit task for execution\n   */\n  async submitTask(task: Omit<TaskEnvelope, 'requester' | 'deadline' | 'priority'>): Promise<string> {\n    const envelope: TaskEnvelope = {\n      ...task,\n      requester: this.agentId,\n      deadline: Date.now() + task.budgets.timeoutMs,\n      priority: 1,\n    };\n\n    return this.publish('tasks', envelope);\n  }\n\n  /**\n   * Submit task result with full execution binding\n   * Signs ALL fields including TaskEnvelope binding for complete traceability\n   */\n  async submitResult(receipt: Omit<TaskReceipt, 'signature' | 'executorPubKey'>): Promise<string> {\n    // Create receipt with executor's public key\n    const fullReceipt: Omit<TaskReceipt, 'signature'> = {\n      ...receipt,\n      executorPubKey: this.identity.getPublicKey(),\n    };\n\n    // Sign ALL fields using canonical serialization for full execution binding\n    // This includes the new TaskEnvelope binding fields\n    const dataToSign = {\n      endTimestamp: fullReceipt.endTimestamp,\n      entrypoint: fullReceipt.entrypoint,\n      executionMs: fullReceipt.executionMs,\n      executor: fullReceipt.executor,\n      executorPubKey: fullReceipt.executorPubKey,\n      fuelUsed: fullReceipt.fuelUsed,\n      inputCID: fullReceipt.inputCID,\n      inputHash: fullReceipt.inputHash,\n      memoryPeakMB: fullReceipt.memoryPeakMB,\n      moduleCID: fullReceipt.moduleCID,\n      moduleHash: fullReceipt.moduleHash,\n      outputHash: fullReceipt.outputHash,\n      outputSchemaHash: fullReceipt.outputSchemaHash,\n      resultCID: fullReceipt.resultCID,\n      startTimestamp: fullReceipt.startTimestamp,\n      status: fullReceipt.status,\n      taskEnvelopeHash: fullReceipt.taskEnvelopeHash,\n      taskId: fullReceipt.taskId,\n    };\n\n    const signature = this.identity.sign(stableStringify(dataToSign));\n    const signedReceipt: TaskReceipt = { ...fullReceipt, signature };\n\n    return this.publish('results', signedReceipt);\n  }\n\n  /**\n   * Get status\n   */\n  getStatus(): {\n    connected: boolean;\n    swarmId: string;\n    agentId: string;\n    publicKey: string;\n    relays: { total: number; healthy: number; avgLatency: number };\n  } {\n    return {\n      connected: this.connected,\n      swarmId: this.swarmId,\n      agentId: this.agentId,\n      publicKey: this.identity.getPublicKey().slice(0, 50) + '...',\n      relays: this.relayManager.getMetrics(),\n    };\n  }\n\n  /**\n   * Get swarm key for sharing\n   */\n  getSwarmKey(): string {\n    return this.swarmKey.toString('base64');\n  }\n\n  //===========================================================================\n  // AUTONOMY: Membership Watcher, Heartbeats, Task Executor\n  //===========================================================================\n\n  /**\n   * Start membership watcher\n   * Continuously monitors the members map, verifies registrations, tracks liveness\n   */\n  private startMembershipWatcher(): void {\n    if (!this.swarmNode) return;\n\n    // Subscribe to all member registrations\n    this.swarmNode.get('members').map().on((registration: any, agentId: string) => {\n      if (!registration || !agentId) return;\n      if (agentId === this.agentId) return; // Skip self\n\n      // Verify the registration\n      const verified = this.verifyMemberRegistration(registration);\n      if (verified) {\n        // Check if this is an update or new member\n        const existing = this.memberRegistry.get(agentId);\n        if (existing) {\n          // Keep the higher lastSeen (heartbeat updates this separately)\n          verified.lastSeen = Math.max(existing.lastSeen, verified.lastSeen);\n        }\n        this.memberRegistry.set(agentId, verified);\n        // Remove from negative cache\n        this.negativeMemberCache.delete(agentId);\n\n        logger.debug('Member verified via watcher', { agentId, capabilities: verified.capabilities });\n      }\n    });\n\n    // Subscribe to heartbeats\n    this.subscribeToHeartbeats();\n\n    logger.debug('Membership watcher started');\n  }\n\n  /**\n   * Subscribe to heartbeat messages to track liveness\n   * Explicitly rejects agentId mismatches to prevent confusion attacks\n   */\n  private subscribeToHeartbeats(): void {\n    this.subscribe('heartbeat', (data: any, from: string) => {\n      // Reject if payload agentId doesn't match envelope sender\n      if (data?.agentId && data.agentId !== from) {\n        logger.warn('Heartbeat agentId mismatch', { from, claimed: data.agentId });\n        return;\n      }\n\n      const member = this.memberRegistry.get(from);\n      if (member) {\n        member.lastSeen = Date.now();\n        logger.debug('Heartbeat received', { from, lastSeen: member.lastSeen });\n      }\n    });\n  }\n\n  /**\n   * Start publishing heartbeats\n   * Every HEARTBEAT_INTERVAL_MS, publish a signed heartbeat message\n   */\n  private startHeartbeat(): void {\n    // Publish initial heartbeat\n    this.publishHeartbeat();\n\n    // Start interval\n    this.heartbeatInterval = setInterval(() => {\n      this.publishHeartbeat();\n    }, this.HEARTBEAT_INTERVAL_MS);\n\n    logger.debug('Heartbeat publishing started', { intervalMs: this.HEARTBEAT_INTERVAL_MS });\n  }\n\n  /**\n   * Publish a single heartbeat\n   * Belt-and-suspenders: check both connected and swarmNode\n   */\n  private async publishHeartbeat(): Promise<void> {\n    if (!this.connected || !this.swarmNode) return;\n\n    await this.publish('heartbeat', {\n      agentId: this.agentId,\n      timestamp: Date.now(),\n      status: 'alive',\n      capabilities: ['coordinator', 'executor'],\n      claimedTasks: this.claimedTasks.size,\n    });\n\n    // Update own lastSeen\n    const self = this.memberRegistry.get(this.agentId);\n    if (self) {\n      self.lastSeen = Date.now();\n    }\n  }\n\n  /**\n   * Get list of live members (heartbeat within MEMBER_TIMEOUT_MS)\n   */\n  getLiveMembers(): Array<{\n    agentId: string;\n    capabilities: string[];\n    lastSeen: number;\n    isAlive: boolean;\n  }> {\n    const now = Date.now();\n    const members: Array<{\n      agentId: string;\n      capabilities: string[];\n      lastSeen: number;\n      isAlive: boolean;\n    }> = [];\n\n    const entries = Array.from(this.memberRegistry.entries());\n    for (const [agentId, member] of entries) {\n      if (!member.verified) continue;\n\n      const isAlive = (now - member.lastSeen) < this.MEMBER_TIMEOUT_MS;\n      members.push({\n        agentId,\n        capabilities: member.capabilities,\n        lastSeen: member.lastSeen,\n        isAlive,\n      });\n    }\n\n    return members;\n  }\n\n  /**\n   * Get count of live members\n   */\n  getLiveMemberCount(): number {\n    return this.getLiveMembers().filter(m => m.isAlive).length;\n  }\n\n  //===========================================================================\n  // RECEIPT VERIFICATION\n  //===========================================================================\n\n  /**\n   * Verify a task receipt\n   *\n   * Checks:\n   * 1. Executor is in verified member registry\n   * 2. Executor public key matches registry\n   * 3. Signature is valid over the canonical receipt fields\n   * 4. Optionally verifies taskEnvelopeHash if original task is provided\n   */\n  async verifyReceipt(receipt: TaskReceipt, originalTask?: TaskEnvelope): Promise<{\n    valid: boolean;\n    reason?: string;\n    executor?: {\n      agentId: string;\n      capabilities: string[];\n      verified: boolean;\n    };\n  }> {\n    // 1. Resolve executor from registry\n    const executor = await this.resolveMember(receipt.executor);\n    if (!executor) {\n      return { valid: false, reason: 'Executor not in verified registry' };\n    }\n\n    // 2. Verify executor public key matches\n    if (executor.publicKey !== receipt.executorPubKey) {\n      return { valid: false, reason: 'Executor public key mismatch with registry' };\n    }\n\n    // 3. Reconstruct the signed data (must EXACTLY match submitResult signing set)\n    // All fields in alphabetical order for stableStringify consistency\n    const dataToVerify = {\n      endTimestamp: receipt.endTimestamp,\n      entrypoint: receipt.entrypoint,\n      executionMs: receipt.executionMs,\n      executor: receipt.executor,\n      executorPubKey: receipt.executorPubKey,\n      fuelUsed: receipt.fuelUsed,\n      inputCID: receipt.inputCID,\n      inputHash: receipt.inputHash,\n      memoryPeakMB: receipt.memoryPeakMB,\n      moduleCID: receipt.moduleCID,\n      moduleHash: receipt.moduleHash,\n      outputHash: receipt.outputHash,\n      outputSchemaHash: receipt.outputSchemaHash,\n      resultCID: receipt.resultCID,\n      startTimestamp: receipt.startTimestamp,\n      status: receipt.status,\n      taskEnvelopeHash: receipt.taskEnvelopeHash,\n      taskId: receipt.taskId,\n    };\n\n    // 4. Verify signature using registry key\n    if (!this.identity.verify(stableStringify(dataToVerify), receipt.signature, executor.publicKey)) {\n      return { valid: false, reason: 'Invalid receipt signature' };\n    }\n\n    // 5. Optionally verify taskEnvelopeHash\n    if (originalTask) {\n      const expectedHash = this.crypto.hash(stableStringify(originalTask));\n      if (receipt.taskEnvelopeHash !== expectedHash) {\n        return { valid: false, reason: 'Task envelope hash mismatch' };\n      }\n    }\n\n    return {\n      valid: true,\n      executor: {\n        agentId: executor.agentId,\n        capabilities: executor.capabilities,\n        verified: executor.verified,\n      },\n    };\n  }\n\n  //===========================================================================\n  // TASK EXECUTOR LOOP (optional, enable with startTaskExecutor)\n  //===========================================================================\n\n  /**\n   * Start the task executor loop\n   * Subscribes to tasks, claims them, and (in production) executes in Wasmtime\n   *\n   * Security checks:\n   * - Requester must be verified member\n   * - Requester in envelope must match sender\n   * - Executor must have 'executor' capability\n   */\n  startTaskExecutor(): void {\n    if (this.taskExecutorActive) return;\n    this.taskExecutorActive = true;\n\n    this.subscribe('tasks', async (task: TaskEnvelope, from: string) => {\n      // Skip if not from a verified member\n      const requester = await this.resolveMember(from);\n      if (!requester) {\n        logger.debug('Task from unverified requester, skipping', { from });\n        return;\n      }\n\n      // Reject if task.requester doesn't match envelope sender (prevents replay/confusion)\n      if (task.requester && task.requester !== from) {\n        logger.warn('Task requester mismatch', {\n          from,\n          requester: task.requester,\n          taskId: task.taskId,\n        });\n        return;\n      }\n\n      // Check if we have executor capability\n      const self = this.memberRegistry.get(this.agentId);\n      if (!self || !self.capabilities.includes('executor')) {\n        logger.debug('Not an executor, skipping task', { taskId: task.taskId });\n        return;\n      }\n\n      // Skip if already claimed\n      if (this.claimedTasks.has(task.taskId)) {\n        return;\n      }\n\n      // Skip if past deadline\n      if (Date.now() > task.deadline) {\n        logger.debug('Task past deadline, skipping', { taskId: task.taskId });\n        return;\n      }\n\n      // Attempt to claim the task\n      const claimed = await this.claimTask(task);\n      if (!claimed) {\n        return;\n      }\n\n      // Execute the task\n      try {\n        const receipt = await this.executeTask(task);\n        await this.submitResult(receipt);\n        logger.info('Task completed', { taskId: task.taskId, status: receipt.status });\n      } catch (error) {\n        logger.error('Task execution failed', { taskId: task.taskId, error });\n        // Submit error receipt (async for consistent artifact hashing)\n        const errorReceipt = await this.createErrorReceipt(task, error as Error);\n        await this.submitResult(errorReceipt);\n      } finally {\n        this.claimedTasks.delete(task.taskId);\n      }\n    });\n\n    logger.info('Task executor started');\n  }\n\n  /**\n   * Claim a task with conflict resolution\n   *\n   * Before claiming:\n   * 1. Check for existing claim\n   * 2. If claim exists and is fresh (< CLAIM_TTL_MS), skip\n   * 3. If no claim or stale, write our claim\n   *\n   * Uses single timestamp to ensure signature matches stored data\n   */\n  private async claimTask(task: TaskEnvelope): Promise<boolean> {\n    if (!this.swarmNode) return false;\n\n    // Check for existing claim (conflict resolution)\n    let existing = await new Promise<any>((resolve) => {\n      let done = false;\n      this.swarmNode!.get('claims').get(task.taskId).once((c: any) => {\n        if (done) return;\n        done = true;\n        resolve(c);\n      });\n      setTimeout(() => {\n        if (!done) {\n          done = true;\n          resolve(null);\n        }\n      }, 1500);\n    });\n\n    // Verify existing claim signature against registry to prevent spoofing\n    if (existing?.executor && existing?.claimedAt && existing?.signature) {\n      const execKey = await this.resolveMemberKey(existing.executor);\n      if (execKey) {\n        const claimValid = this.identity.verify(\n          stableStringify({\n            claimedAt: existing.claimedAt,\n            executor: existing.executor,\n            taskEnvelopeHash: existing.taskEnvelopeHash,\n            taskId: task.taskId,\n          }),\n          existing.signature,\n          execKey\n        );\n\n        if (!claimValid) {\n          // Treat invalid claim as non-existent (spoofed)\n          logger.debug('Ignoring invalid claim signature', {\n            taskId: task.taskId,\n            claimedBy: existing.executor,\n          });\n          existing = null;\n        }\n      } else {\n        // Executor not in registry - ignore claim\n        existing = null;\n      }\n    }\n\n    // If fresh VERIFIED claim exists from another agent, don't compete\n    if (existing?.claimedAt &&\n        (Date.now() - existing.claimedAt) < this.CLAIM_TTL_MS &&\n        existing.executor !== this.agentId) {\n      logger.debug('Task already claimed by another agent', {\n        taskId: task.taskId,\n        claimedBy: existing.executor,\n      });\n      return false;\n    }\n\n    // Create claim with single timestamp for consistency\n    const claimedAt = Date.now();\n    const taskEnvelopeHash = this.crypto.hash(stableStringify(task));\n\n    const claim = {\n      taskId: task.taskId,\n      executor: this.agentId,\n      claimedAt,\n      taskEnvelopeHash,\n      signature: this.identity.sign(stableStringify({\n        claimedAt,\n        executor: this.agentId,\n        taskEnvelopeHash,\n        taskId: task.taskId,\n      })),\n    };\n\n    // Publish claim to Gun\n    this.swarmNode.get('claims').get(task.taskId).put(claim);\n\n    // Add to local claimed set\n    this.claimedTasks.add(task.taskId);\n\n    logger.debug('Task claimed', { taskId: task.taskId });\n    return true;\n  }\n\n  /**\n   * Execute a task\n   *\n   * NOTE: This is a stub. In production, this would:\n   * 1. Fetch WASM module from IPFS using moduleCID\n   * 2. Fetch input data from IPFS using inputCID\n   * 3. Execute in Wasmtime with fuel, memory, and timeout limits\n   * 4. Store output to IPFS, get resultCID\n   * 5. Return signed receipt\n   *\n   * Hashes actual bytes when available for meaningful receipts\n   */\n  private async executeTask(task: TaskEnvelope): Promise<Omit<TaskReceipt, 'signature' | 'executorPubKey'>> {\n    const startTimestamp = Date.now();\n\n    // Fetch artifacts (may be null if not in local cache)\n    const inputBytes = await this.artifactStore.retrieve(task.inputCID);\n    const moduleBytes = await this.artifactStore.retrieve(task.moduleCID);\n\n    // Hash actual bytes when available, fall back to CID string if not\n    const inputHash = inputBytes\n      ? this.crypto.hash(inputBytes)\n      : this.crypto.hash(task.inputCID);\n    const moduleHash = moduleBytes\n      ? this.crypto.hash(moduleBytes)\n      : this.crypto.hash(task.moduleCID);\n\n    // Stub execution - in production use Wasmtime with moduleBytes\n    // const result = await wasmtime.execute(moduleBytes, inputBytes, task.budgets);\n\n    const endTimestamp = Date.now();\n    const taskEnvelopeHash = this.crypto.hash(stableStringify(task));\n\n    // Store result artifact\n    const resultData = JSON.stringify({\n      taskId: task.taskId,\n      status: 'success',\n      output: 'Stub execution completed',\n      timestamp: endTimestamp,\n    });\n\n    // Hash actual output bytes\n    const outputBytes = Buffer.from(resultData);\n    const outputHash = this.crypto.hash(outputBytes);\n\n    const { cid: resultCID } = await this.artifactStore.store(resultData);\n\n    return {\n      taskId: task.taskId,\n      executor: this.agentId,\n      resultCID,\n      status: 'success',\n      fuelUsed: 1000,\n      memoryPeakMB: 1,\n      executionMs: endTimestamp - startTimestamp,\n      inputHash,\n      outputHash,\n      moduleHash,\n      startTimestamp,\n      endTimestamp,\n      moduleCID: task.moduleCID,\n      inputCID: task.inputCID,\n      entrypoint: task.entrypoint,\n      outputSchemaHash: task.outputSchemaHash,\n      taskEnvelopeHash,\n    };\n  }\n\n  /**\n   * Create error receipt for failed task\n   * Uses same hashing semantics as executeTask for consistency\n   */\n  private async createErrorReceipt(task: TaskEnvelope, error: Error): Promise<Omit<TaskReceipt, 'signature' | 'executorPubKey'>> {\n    const now = Date.now();\n\n    // Hash actual bytes when available for consistency with executeTask\n    const inputBytes = await this.artifactStore.retrieve(task.inputCID);\n    const moduleBytes = await this.artifactStore.retrieve(task.moduleCID);\n\n    const inputHash = inputBytes\n      ? this.crypto.hash(inputBytes)\n      : this.crypto.hash(task.inputCID);\n    const moduleHash = moduleBytes\n      ? this.crypto.hash(moduleBytes)\n      : this.crypto.hash(task.moduleCID);\n\n    // Hash error message as output\n    const outputHash = this.crypto.hash(Buffer.from(error.message));\n\n    return {\n      taskId: task.taskId,\n      executor: this.agentId,\n      resultCID: '',\n      status: 'error',\n      fuelUsed: 0,\n      memoryPeakMB: 0,\n      executionMs: 0,\n      inputHash,\n      outputHash,\n      moduleHash,\n      startTimestamp: now,\n      endTimestamp: now,\n      moduleCID: task.moduleCID,\n      inputCID: task.inputCID,\n      entrypoint: task.entrypoint,\n      outputSchemaHash: task.outputSchemaHash,\n      taskEnvelopeHash: this.crypto.hash(stableStringify(task)),\n    };\n  }\n\n  /**\n   * Stop task executor\n   */\n  stopTaskExecutor(): void {\n    this.taskExecutorActive = false;\n    logger.info('Task executor stopped');\n  }\n\n  /**\n   * Disconnect and cleanup resources\n   */\n  disconnect(): void {\n    this.connected = false;\n\n    // Stop heartbeat\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n\n    // Stop task executor\n    this.taskExecutorActive = false;\n\n    this.identity.destroy(); // Stop nonce cleanup interval\n    this.messageHandlers.clear();\n    this.pendingOffers.clear();\n    this.claimedTasks.clear();\n    this.negativeMemberCache.clear();\n    // Gun doesn't have explicit disconnect\n  }\n}\n\n//=============================================================================\n// RUVECTOR OPTIMIZATION LAYER\n//=============================================================================\n\n/**\n * RuVector optimization for Gun message handling\n *\n * Provides:\n * - HNSW indexing for O(log n) message lookup by topic similarity\n * - Batch message operations for reduced overhead\n * - PQ quantization for compressed message metadata storage\n * - Vector-based topic routing for intelligent distribution\n */\nclass RuVectorGunOptimizer {\n  private topicVectors: Map<string, Float32Array> = new Map();\n  private messageIndex: Map<string, string[]> = new Map(); // topic -> messageIds\n  private batchQueue: Array<{ topic: string; payload: any }> = [];\n  private batchFlushInterval: NodeJS.Timeout | null = null;\n  private readonly batchSize = 10;\n  private readonly flushIntervalMs = 100;\n\n  constructor() {\n    this.startBatchFlusher();\n  }\n\n  /**\n   * Generate topic embedding using simple hash-based vectors\n   * In production: use actual embedding model via ruvector\n   */\n  private generateTopicVector(topic: string): Float32Array {\n    // Create 128-dimensional vector from topic hash\n    const hash = topic.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const vector = new Float32Array(128);\n    for (let i = 0; i < 128; i++) {\n      vector[i] = Math.sin(hash * (i + 1) * 0.1) * 0.5 + 0.5;\n    }\n    return vector;\n  }\n\n  /**\n   * Find similar topics using cosine similarity\n   * In production: use HNSW index via ruvector for O(log n) lookup\n   */\n  findSimilarTopics(topic: string, topK: number = 5): Array<{ topic: string; similarity: number }> {\n    const queryVector = this.generateTopicVector(topic);\n    const similarities: Array<{ topic: string; similarity: number }> = [];\n\n    const entries = Array.from(this.topicVectors.entries());\n    for (const [existingTopic, vector] of entries) {\n      const similarity = this.cosineSimilarity(queryVector, vector);\n      similarities.push({ topic: existingTopic, similarity });\n    }\n\n    // Sort by similarity and return top K\n    return similarities\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, topK);\n  }\n\n  /**\n   * Cosine similarity between two vectors\n   */\n  private cosineSimilarity(a: Float32Array, b: Float32Array): number {\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n\n  /**\n   * Index a topic for similarity search\n   */\n  indexTopic(topic: string): void {\n    if (!this.topicVectors.has(topic)) {\n      this.topicVectors.set(topic, this.generateTopicVector(topic));\n      this.messageIndex.set(topic, []);\n    }\n  }\n\n  /**\n   * Add message to batch queue for efficient Gun writes\n   */\n  queueMessage(topic: string, payload: any): void {\n    this.indexTopic(topic);\n    this.batchQueue.push({ topic, payload });\n\n    // Flush immediately if batch is full\n    if (this.batchQueue.length >= this.batchSize) {\n      this.flushBatch();\n    }\n  }\n\n  /**\n   * Get batched messages for efficient Gun write\n   */\n  flushBatch(): Array<{ topic: string; payload: any }> {\n    const batch = [...this.batchQueue];\n    this.batchQueue = [];\n    return batch;\n  }\n\n  /**\n   * Start periodic batch flushing\n   */\n  private startBatchFlusher(): void {\n    this.batchFlushInterval = setInterval(() => {\n      if (this.batchQueue.length > 0) {\n        this.flushBatch();\n      }\n    }, this.flushIntervalMs);\n  }\n\n  /**\n   * Get optimization metrics\n   */\n  getMetrics(): {\n    indexedTopics: number;\n    batchQueueSize: number;\n    totalMessages: number;\n  } {\n    let totalMessages = 0;\n    const values = Array.from(this.messageIndex.values());\n    for (const messageIds of values) {\n      totalMessages += messageIds.length;\n    }\n\n    return {\n      indexedTopics: this.topicVectors.size,\n      batchQueueSize: this.batchQueue.length,\n      totalMessages,\n    };\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.batchFlushInterval) {\n      clearInterval(this.batchFlushInterval);\n      this.batchFlushInterval = null;\n    }\n  }\n}\n\n/**\n * Create and connect a P2P swarm\n */\nexport async function createP2PSwarmV2(\n  agentId: string,\n  swarmKey?: string\n): Promise<P2PSwarmV2> {\n  const swarm = new P2PSwarmV2(agentId, swarmKey);\n  await swarm.connect();\n  return swarm;\n}\n\nexport {\n  stableStringify,\n  IdentityManager,\n  CryptoV2,\n  RelayManager,\n  ArtifactStore,\n  RuVectorGunOptimizer,\n};\n\nexport type {\n  SignedEnvelope,\n  TaskEnvelope,\n  TaskReceipt,\n  ArtifactPointer,\n};\n"]}