{"version":3,"file":"consolidate.js","sourceRoot":"","sources":["../../../src/reasoningbank/core/consolidate.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAC5B,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAChD,OAAO,EAAE,gBAAgB,EAAE,MAAM,iBAAiB,CAAC;AACnD,OAAO,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAUvC;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,WAAW;IAC/B,MAAM,MAAM,GAAG,UAAU,EAAE,CAAC;IAC5B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAE7B,OAAO,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAC;IAEvD,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC;IACrB,MAAM,QAAQ,GAAG,EAAE,CAAC,oBAAoB,EAAE,CAAC;IAE3C,OAAO,CAAC,GAAG,CAAC,qBAAqB,QAAQ,CAAC,MAAM,kBAAkB,CAAC,CAAC;IAEpE,IAAI,eAAe,GAAG,CAAC,CAAC;IACxB,IAAI,mBAAmB,GAAG,CAAC,CAAC;IAC5B,IAAI,WAAW,GAAG,CAAC,CAAC;IAEpB,uCAAuC;IACvC,eAAe,GAAG,MAAM,mBAAmB,CAAC,QAAQ,EAAE,MAAM,CAAC,WAAW,CAAC,mBAAmB,CAAC,CAAC;IAE9F,gCAAgC;IAChC,mBAAmB,GAAG,MAAM,oBAAoB,CAAC,QAAQ,EAAE,MAAM,CAAC,WAAW,CAAC,uBAAuB,CAAC,CAAC;IAEvG,qCAAqC;IACrC,WAAW,GAAG,EAAE,CAAC,gBAAgB,CAAC;QAChC,UAAU,EAAE,MAAM,CAAC,WAAW,CAAC,cAAc;QAC7C,aAAa,EAAE,MAAM,CAAC,WAAW,CAAC,mBAAmB;KACtD,CAAC,CAAC;IAEH,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;IAE1C,0BAA0B;IAC1B,EAAE,CAAC,qBAAqB,CAAC;QACvB,MAAM,EAAE,KAAK;QACb,eAAe,EAAE,QAAQ,CAAC,MAAM;QAChC,gBAAgB,EAAE,eAAe;QACjC,oBAAoB,EAAE,mBAAmB;QACzC,YAAY,EAAE,WAAW;QACzB,WAAW,EAAE,UAAU;KACxB,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,kCAAkC,eAAe,WAAW,mBAAmB,oBAAoB,WAAW,cAAc,UAAU,IAAI,CAAC,CAAC;IAExJ,EAAE,CAAC,SAAS,CAAC,4BAA4B,EAAE,UAAU,CAAC,CAAC;IACvD,EAAE,CAAC,SAAS,CAAC,2BAA2B,EAAE,eAAe,CAAC,CAAC;IAC3D,EAAE,CAAC,SAAS,CAAC,+BAA+B,EAAE,mBAAmB,CAAC,CAAC;IACnE,EAAE,CAAC,SAAS,CAAC,uBAAuB,EAAE,WAAW,CAAC,CAAC;IAEnD,OAAO;QACL,cAAc,EAAE,QAAQ,CAAC,MAAM;QAC/B,eAAe;QACf,mBAAmB;QACnB,WAAW;QACX,UAAU;KACX,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,KAAK,UAAU,mBAAmB,CAChC,QAAe,EACf,SAAiB;IAEjB,IAAI,eAAe,GAAG,CAAC,CAAC;IAExB,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,CAAC,CAAC;IAEpC,sEAAsE;IACtE,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC;IAC1B,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IACpC,MAAM,YAAY,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAClD,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,0DAA0D,YAAY,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAA0C,CAAC;IAE5J,MAAM,aAAa,GAAG,IAAI,GAAG,EAAwB,CAAC;IACtD,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1D,CAAC;IAED,8DAA8D;IAC9D,6EAA6E;IAC7E,MAAM,OAAO,GAAG,IAAI,GAAG,EAAiB,CAAC;IACzC,MAAM,kBAAkB,GAAG,EAAE,CAAC,CAAC,kCAAkC;IAEjE,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE,CAAC;QAC3B,MAAM,GAAG,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACtC,IAAI,CAAC,GAAG;YAAE,SAAS;QAEnB,qCAAqC;QACrC,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,MAAM,GAAG,CAAC,QAAQ,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,sBAAsB;YACzE,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,EAAE,CAAC;gBAC9B,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1B,MAAM,GAAG,CAAC,CAAC;YACb,CAAC;QACH,CAAC;QACD,MAAM,SAAS,GAAG,MAAM,GAAG,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,kBAAkB,GAAG,CAAC,CAAC,CAAC;QAEvG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;YAC5B,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;QAC7B,CAAC;QACD,OAAO,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACpC,CAAC;IAED,mEAAmE;IACnE,MAAM,UAAU,GAAG,IAAI,GAAG,EAAU,CAAC;IAErC,KAAK,MAAM,CAAC,SAAS,EAAE,cAAc,CAAC,IAAI,OAAO,EAAE,CAAC;QAClD,wBAAwB;QACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/C,MAAM,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAI,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBAAE,SAAS;YAEtC,MAAM,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACxC,IAAI,CAAC,IAAI;gBAAE,SAAS;YAEpB,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACnD,MAAM,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC/B,IAAI,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;oBAAE,SAAS;gBAEtC,MAAM,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACxC,IAAI,CAAC,IAAI;oBAAE,SAAS;gBAEpB,MAAM,UAAU,GAAG,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAEhD,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC;oBAC5B,oBAAoB;oBACpB,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;oBAC3D,eAAe,EAAE,CAAC;oBAElB,wCAAwC;oBACxC,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;wBACxC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;wBACxB,OAAO,CAAC,GAAG,CAAC,4BAA4B,IAAI,CAAC,YAAY,EAAE,KAAK,IAAI,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,YAAY,EAAE,KAAK,IAAI,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;oBAC1H,CAAC;yBAAM,CAAC;wBACN,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;oBAC1B,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,sDAAsD;IACtD,IAAI,UAAU,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;QACxB,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACzC,MAAM,kBAAkB,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC9D,MAAM,CAAC,OAAO,CAAC,qCAAqC,kBAAkB,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC;IAC/F,CAAC;IAED,OAAO,eAAe,CAAC;AACzB,CAAC;AAED;;;;GAIG;AACH,KAAK,UAAU,oBAAoB,CACjC,QAAe,EACf,SAAiB,EACjB,mBAA+C;IAE/C,IAAI,mBAAmB,GAAG,CAAC,CAAC;IAE5B,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,CAAC,CAAC;IAEpC,kEAAkE;IAClE,IAAI,aAAwC,CAAC;IAE7C,IAAI,mBAAmB,EAAE,CAAC;QACxB,aAAa,GAAG,mBAAmB,CAAC;IACtC,CAAC;SAAM,CAAC;QACN,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC;QAC1B,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACpC,MAAM,YAAY,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAClD,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,0DAA0D,YAAY,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAA0C,CAAC;QAE5J,aAAa,GAAG,IAAI,GAAG,EAAwB,CAAC;QAChD,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;YACvB,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;QAC1D,CAAC;IACH,CAAC;IAED,8EAA8E;IAC9E,MAAM,aAAa,GAAG,IAAI,GAAG,EAAiB,CAAC;IAE/C,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE,CAAC;QAC3B,MAAM,OAAO,GAAG,GAAG,CAAC,YAAY,EAAE,MAAM,EAAE,OAAO,IAAI,SAAS,CAAC;QAC/D,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC;YAChC,aAAa,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;QACjC,CAAC;QACD,aAAa,CAAC,GAAG,CAAC,OAAO,CAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACxC,CAAC;IAED,gDAAgD;IAChD,MAAM,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC;IAErD,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC;QAC/C,KAAK,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC;YACpD,MAAM,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,CAAE,CAAC;YACnD,MAAM,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,CAAE,CAAC;YAEnD,6CAA6C;YAC7C,KAAK,MAAM,IAAI,IAAI,MAAM,EAAE,CAAC;gBAC1B,MAAM,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACxC,IAAI,CAAC,IAAI;oBAAE,SAAS;gBAEpB,KAAK,MAAM,IAAI,IAAI,MAAM,EAAE,CAAC;oBAC1B,MAAM,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;oBACxC,IAAI,CAAC,IAAI;wBAAE,SAAS;oBAEpB,MAAM,UAAU,GAAG,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;oBAEhD,yDAAyD;oBACzD,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC;wBAC5B,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,aAAa,EAAE,UAAU,CAAC,CAAC;wBAC1D,mBAAmB,EAAE,CAAC;wBACtB,OAAO,CAAC,GAAG,CAAC,kCAAkC,IAAI,CAAC,YAAY,EAAE,KAAK,IAAI,IAAI,CAAC,EAAE,OAAO,IAAI,CAAC,YAAY,EAAE,KAAK,IAAI,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;oBACjI,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,mBAAmB,CAAC;AAC7B,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,iBAAiB;IAC/B,MAAM,MAAM,GAAG,UAAU,EAAE,CAAC;IAC5B,MAAM,QAAQ,GAAG,EAAE,CAAC,kCAAkC,EAAE,CAAC;IACzD,OAAO,QAAQ,IAAI,MAAM,CAAC,WAAW,CAAC,iBAAiB,CAAC;AAC1D,CAAC","sourcesContent":["/**\n * Memory Consolidation\n * Algorithm 4 from ReasoningBank paper: Dedup, Contradict, Prune\n */\n\nimport { ulid } from 'ulid';\nimport { loadConfig } from '../utils/config.js';\nimport { cosineSimilarity } from '../utils/mmr.js';\nimport * as db from '../db/queries.js';\n\nexport interface ConsolidationResult {\n  itemsProcessed: number;\n  duplicatesFound: number;\n  contradictionsFound: number;\n  itemsPruned: number;\n  durationMs: number;\n}\n\n/**\n * Run consolidation: deduplicate, detect contradictions, prune old memories\n */\nexport async function consolidate(): Promise<ConsolidationResult> {\n  const config = loadConfig();\n  const startTime = Date.now();\n\n  console.log('[INFO] Starting memory consolidation...');\n\n  const runId = ulid();\n  const memories = db.getAllActiveMemories();\n\n  console.log(`[INFO] Processing ${memories.length} active memories`);\n\n  let duplicatesFound = 0;\n  let contradictionsFound = 0;\n  let itemsPruned = 0;\n\n  // Step 1: Deduplicate similar memories\n  duplicatesFound = await deduplicateMemories(memories, config.consolidate.duplicate_threshold);\n\n  // Step 2: Detect contradictions\n  contradictionsFound = await detectContradictions(memories, config.consolidate.contradiction_threshold);\n\n  // Step 3: Prune old, unused memories\n  itemsPruned = db.pruneOldMemories({\n    maxAgeDays: config.consolidate.prune_age_days,\n    minConfidence: config.consolidate.min_confidence_keep\n  });\n\n  const durationMs = Date.now() - startTime;\n\n  // Store consolidation run\n  db.storeConsolidationRun({\n    run_id: runId,\n    items_processed: memories.length,\n    duplicates_found: duplicatesFound,\n    contradictions_found: contradictionsFound,\n    items_pruned: itemsPruned,\n    duration_ms: durationMs\n  });\n\n  console.log(`[INFO] Consolidation complete: ${duplicatesFound} dupes, ${contradictionsFound} contradictions, ${itemsPruned} pruned in ${durationMs}ms`);\n\n  db.logMetric('rb.consolidate.duration_ms', durationMs);\n  db.logMetric('rb.consolidate.duplicates', duplicatesFound);\n  db.logMetric('rb.consolidate.contradictions', contradictionsFound);\n  db.logMetric('rb.consolidate.pruned', itemsPruned);\n\n  return {\n    itemsProcessed: memories.length,\n    duplicatesFound,\n    contradictionsFound,\n    itemsPruned,\n    durationMs\n  };\n}\n\n/**\n * Deduplicate highly similar memories\n * PERFORMANCE FIX: Use bucketing/blocking to reduce O(n²) to ~O(n·k)\n * by only comparing memories within the same semantic bucket\n */\nasync function deduplicateMemories(\n  memories: any[],\n  threshold: number\n): Promise<number> {\n  let duplicatesFound = 0;\n\n  if (memories.length === 0) return 0;\n\n  // Fetch all embeddings in a single batch query (instead of N queries)\n  const dbConn = db.getDb();\n  const ids = memories.map(m => m.id);\n  const placeholders = ids.map(() => '?').join(',');\n  const rows = dbConn.prepare(`SELECT id, vector FROM pattern_embeddings WHERE id IN (${placeholders})`).all(...ids) as Array<{ id: string; vector: Buffer }>;\n\n  const embeddingsMap = new Map<string, Float32Array>();\n  for (const row of rows) {\n    embeddingsMap.set(row.id, new Float32Array(row.vector));\n  }\n\n  // PERFORMANCE: Use locality-sensitive hashing (LSH) bucketing\n  // Group memories by their dominant embedding dimension to reduce comparisons\n  const buckets = new Map<number, any[]>();\n  const BUCKET_GRANULARITY = 10; // Number of buckets per dimension\n\n  for (const mem of memories) {\n    const emb = embeddingsMap.get(mem.id);\n    if (!emb) continue;\n\n    // Find dominant dimension and bucket\n    let maxDim = 0;\n    let maxVal = -Infinity;\n    for (let i = 0; i < Math.min(emb.length, 32); i++) { // Check first 32 dims\n      if (Math.abs(emb[i]) > maxVal) {\n        maxVal = Math.abs(emb[i]);\n        maxDim = i;\n      }\n    }\n    const bucketKey = maxDim * BUCKET_GRANULARITY + Math.floor((emb[maxDim] + 1) * BUCKET_GRANULARITY / 2);\n\n    if (!buckets.has(bucketKey)) {\n      buckets.set(bucketKey, []);\n    }\n    buckets.get(bucketKey)!.push(mem);\n  }\n\n  // Compare only within buckets (and neighboring buckets for safety)\n  const deletedIds = new Set<string>();\n\n  for (const [bucketKey, bucketMemories] of buckets) {\n    // Compare within bucket\n    for (let i = 0; i < bucketMemories.length; i++) {\n      const mem1 = bucketMemories[i];\n      if (deletedIds.has(mem1.id)) continue;\n\n      const emb1 = embeddingsMap.get(mem1.id);\n      if (!emb1) continue;\n\n      for (let j = i + 1; j < bucketMemories.length; j++) {\n        const mem2 = bucketMemories[j];\n        if (deletedIds.has(mem2.id)) continue;\n\n        const emb2 = embeddingsMap.get(mem2.id);\n        if (!emb2) continue;\n\n        const similarity = cosineSimilarity(emb1, emb2);\n\n        if (similarity >= threshold) {\n          // Mark as duplicate\n          db.storeLink(mem1.id, mem2.id, 'duplicate_of', similarity);\n          duplicatesFound++;\n\n          // Merge: keep the one with higher usage\n          if (mem1.usage_count < mem2.usage_count) {\n            deletedIds.add(mem1.id);\n            console.log(`[INFO] Merged duplicate: ${mem1.pattern_data?.title || mem1.id} → ${mem2.pattern_data?.title || mem2.id}`);\n          } else {\n            deletedIds.add(mem2.id);\n          }\n        }\n      }\n    }\n  }\n\n  // Batch delete all duplicates in a single transaction\n  if (deletedIds.size > 0) {\n    const deleteIds = Array.from(deletedIds);\n    const deletePlaceholders = deleteIds.map(() => '?').join(',');\n    dbConn.prepare(`DELETE FROM patterns WHERE id IN (${deletePlaceholders})`).run(...deleteIds);\n  }\n\n  return duplicatesFound;\n}\n\n/**\n * Detect contradicting memories\n * Uses embedding similarity + semantic analysis\n * PERFORMANCE FIX: Reuses embeddings from deduplication phase and uses bucketing\n */\nasync function detectContradictions(\n  memories: any[],\n  threshold: number,\n  preloadedEmbeddings?: Map<string, Float32Array>\n): Promise<number> {\n  let contradictionsFound = 0;\n\n  if (memories.length === 0) return 0;\n\n  // Use preloaded embeddings if available, otherwise fetch in batch\n  let embeddingsMap: Map<string, Float32Array>;\n\n  if (preloadedEmbeddings) {\n    embeddingsMap = preloadedEmbeddings;\n  } else {\n    const dbConn = db.getDb();\n    const ids = memories.map(m => m.id);\n    const placeholders = ids.map(() => '?').join(',');\n    const rows = dbConn.prepare(`SELECT id, vector FROM pattern_embeddings WHERE id IN (${placeholders})`).all(...ids) as Array<{ id: string; vector: Buffer }>;\n\n    embeddingsMap = new Map<string, Float32Array>();\n    for (const row of rows) {\n      embeddingsMap.set(row.id, new Float32Array(row.vector));\n    }\n  }\n\n  // PERFORMANCE: Group by outcome first, only compare across different outcomes\n  const outcomeGroups = new Map<string, any[]>();\n\n  for (const mem of memories) {\n    const outcome = mem.pattern_data?.source?.outcome ?? 'unknown';\n    if (!outcomeGroups.has(outcome)) {\n      outcomeGroups.set(outcome, []);\n    }\n    outcomeGroups.get(outcome)!.push(mem);\n  }\n\n  // Only compare memories with different outcomes\n  const outcomeKeys = Array.from(outcomeGroups.keys());\n\n  for (let o1 = 0; o1 < outcomeKeys.length; o1++) {\n    for (let o2 = o1 + 1; o2 < outcomeKeys.length; o2++) {\n      const group1 = outcomeGroups.get(outcomeKeys[o1])!;\n      const group2 = outcomeGroups.get(outcomeKeys[o2])!;\n\n      // Compare across groups (different outcomes)\n      for (const mem1 of group1) {\n        const emb1 = embeddingsMap.get(mem1.id);\n        if (!emb1) continue;\n\n        for (const mem2 of group2) {\n          const emb2 = embeddingsMap.get(mem2.id);\n          if (!emb2) continue;\n\n          const similarity = cosineSimilarity(emb1, emb2);\n\n          // High similarity but different outcomes = contradiction\n          if (similarity >= threshold) {\n            db.storeLink(mem1.id, mem2.id, 'contradicts', similarity);\n            contradictionsFound++;\n            console.log(`[WARN] Contradiction detected: ${mem1.pattern_data?.title || mem1.id} vs ${mem2.pattern_data?.title || mem2.id}`);\n          }\n        }\n      }\n    }\n  }\n\n  return contradictionsFound;\n}\n\n/**\n * Check if consolidation should run\n * Returns true if threshold of new memories is reached\n */\nexport function shouldConsolidate(): boolean {\n  const config = loadConfig();\n  const newCount = db.countNewMemoriesSinceConsolidation();\n  return newCount >= config.consolidate.trigger_threshold;\n}\n"]}