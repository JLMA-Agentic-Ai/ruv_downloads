{"version":3,"file":"neural-substrate.js","sourceRoot":"","sources":["../../src/embeddings/neural-substrate.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Neural Embedding Substrate Integration\n *\n * Wraps ruvector's NeuralSubstrate for agentic-flow agents\n * treating embeddings as a synthetic nervous system.\n *\n * Based on ruvector@0.1.85 neural-embeddings.ts\n */\n\nimport { getOptimizedEmbedder, cosineSimilarity, euclideanDistance } from './optimized-embedder.js';\n\n// ============================================================================\n// Security Constants\n// ============================================================================\n\nconst MAX_TEXT_LENGTH = 10000;      // Maximum input text length\nconst MAX_MEMORIES = 10000;          // Maximum memories in MemoryPhysics\nconst MAX_AGENTS = 1000;             // Maximum agents in swarm\nconst MAX_BASELINE_SAMPLES = 1000;   // Maximum calibration samples\nconst MAX_HISTORY_SIZE = 100;        // Maximum drift history\nconst VALID_ID_PATTERN = /^[a-zA-Z0-9_-]{1,256}$/;\n\n// ============================================================================\n// Security Validation Functions\n// ============================================================================\n\n/**\n * Validate text input length\n */\nfunction validateTextInput(text: string, context: string): void {\n  if (!text || typeof text !== 'string') {\n    throw new Error(`${context}: Input must be a non-empty string`);\n  }\n  if (text.length > MAX_TEXT_LENGTH) {\n    throw new Error(`${context}: Text exceeds maximum length of ${MAX_TEXT_LENGTH} characters`);\n  }\n}\n\n/**\n * Validate ID format\n */\nfunction validateId(id: string, context: string): void {\n  if (!id || typeof id !== 'string') {\n    throw new Error(`${context}: ID must be a non-empty string`);\n  }\n  if (!VALID_ID_PATTERN.test(id)) {\n    throw new Error(`${context}: Invalid ID format. Use 1-256 alphanumeric characters, underscores, or hyphens`);\n  }\n}\n\n/**\n * Validate array is not null and has expected dimension\n */\nfunction validateEmbedding(arr: Float32Array | null, context: string): asserts arr is Float32Array {\n  if (!arr) {\n    throw new Error(`${context}: Not initialized. Call the appropriate setup method first.`);\n  }\n}\n\n// Types matching ruvector's neural-embeddings\nexport interface DriftResult {\n  distance: number;\n  velocity: number;\n  acceleration: number;\n  trend: 'stable' | 'drifting' | 'accelerating' | 'recovering';\n  shouldEscalate: boolean;\n  shouldTriggerReasoning: boolean;\n}\n\nexport interface MemoryEntry {\n  id: string;\n  embedding: Float32Array;\n  content: string;\n  strength: number;\n  timestamp: number;\n  accessCount: number;\n  associations: string[];\n}\n\nexport interface AgentState {\n  id: string;\n  position: Float32Array;\n  velocity: Float32Array;\n  attention: Float32Array;\n  energy: number;\n  lastUpdate: number;\n}\n\nexport interface CoherenceResult {\n  isCoherent: boolean;\n  anomalyScore: number;\n  stabilityScore: number;\n  driftDirection: Float32Array | null;\n  warnings: string[];\n}\n\nexport interface SubstrateHealth {\n  memoryCount: number;\n  activeAgents: number;\n  avgDrift: number;\n  avgCoherence: number;\n  lastConsolidation: number;\n  uptime: number;\n}\n\n/**\n * Semantic Drift Detector\n * Monitors semantic movement and triggers reflexes\n * Optimized with pre-allocated buffers (80-95% less GC pressure)\n */\nexport class SemanticDriftDetector {\n  private embedder = getOptimizedEmbedder();\n  private baseline: Float32Array | null = null;\n  private history: Array<{ embedding: Float32Array; timestamp: number }> = [];\n  private velocity: Float32Array | null = null;\n  private acceleration: Float32Array | null = null;\n  private dimension = 0;\n\n  // Pre-allocated buffer for velocity calculation (reused each detect call)\n  private tempVelocityBuffer: Float32Array | null = null;\n\n  constructor(\n    private driftThreshold = 0.15,\n    private escalationThreshold = 0.30,\n    private historySize = 20\n  ) {}\n\n  async init() {\n    await this.embedder.init();\n  }\n\n  async setBaseline(context: string) {\n    validateTextInput(context, 'SemanticDriftDetector.setBaseline');\n\n    this.baseline = await this.embedder.embed(context);\n    this.dimension = this.baseline.length;\n    this.history = [{ embedding: this.baseline, timestamp: Date.now() }];\n\n    // Pre-allocate buffers once (reused for all subsequent detect calls)\n    if (!this.velocity || this.velocity.length !== this.dimension) {\n      this.velocity = new Float32Array(this.dimension);\n      this.acceleration = new Float32Array(this.dimension);\n      this.tempVelocityBuffer = new Float32Array(this.dimension);\n    } else {\n      // Zero out existing buffers\n      this.velocity.fill(0);\n      this.acceleration!.fill(0);\n    }\n  }\n\n  async detect(input: string): Promise<DriftResult> {\n    validateTextInput(input, 'SemanticDriftDetector.detect');\n    validateEmbedding(this.baseline, 'SemanticDriftDetector.detect');\n\n    const current = await this.embedder.embed(input);\n    const distance = 1 - cosineSimilarity(this.baseline, current);\n\n    // Calculate velocity using pre-allocated buffer (no new allocation!)\n    const prev = this.history[this.history.length - 1]?.embedding || this.baseline!;\n    const newVelocity = this.tempVelocityBuffer!;\n    const dim = this.dimension;\n\n    // 8x unrolled velocity calculation\n    const unrolledLen = dim - (dim % 8);\n    let i = 0;\n    for (; i < unrolledLen; i += 8) {\n      newVelocity[i] = current[i] - prev[i];\n      newVelocity[i+1] = current[i+1] - prev[i+1];\n      newVelocity[i+2] = current[i+2] - prev[i+2];\n      newVelocity[i+3] = current[i+3] - prev[i+3];\n      newVelocity[i+4] = current[i+4] - prev[i+4];\n      newVelocity[i+5] = current[i+5] - prev[i+5];\n      newVelocity[i+6] = current[i+6] - prev[i+6];\n      newVelocity[i+7] = current[i+7] - prev[i+7];\n    }\n    for (; i < dim; i++) {\n      newVelocity[i] = current[i] - prev[i];\n    }\n\n    // Calculate acceleration and update velocity in-place\n    let velocityMagSq = 0;\n    let accelerationMagSq = 0;\n\n    for (i = 0; i < dim; i++) {\n      const oldVel = this.velocity![i];\n      const newVel = newVelocity[i];\n      this.acceleration![i] = newVel - oldVel;\n      this.velocity![i] = newVel;\n      velocityMagSq += newVel * newVel;\n      accelerationMagSq += this.acceleration![i] * this.acceleration![i];\n    }\n\n    const velocityMag = Math.sqrt(velocityMagSq);\n    const accelerationMag = Math.sqrt(accelerationMagSq);\n\n    // Update history\n    this.history.push({ embedding: current, timestamp: Date.now() });\n    if (this.history.length > this.historySize) this.history.shift();\n\n    // Determine trend\n    let trend: DriftResult['trend'] = 'stable';\n    if (accelerationMag > 0.01) trend = 'accelerating';\n    else if (velocityMag > 0.05) trend = 'drifting';\n    else if (distance < this.driftThreshold * 0.5 && velocityMag < 0.02) trend = 'recovering';\n\n    return {\n      distance,\n      velocity: velocityMag,\n      acceleration: accelerationMag,\n      trend,\n      shouldEscalate: distance > this.driftThreshold,\n      shouldTriggerReasoning: distance > this.escalationThreshold\n    };\n  }\n\n  getStats(): { avgDrift: number; maxDrift: number; driftEvents: number } {\n    if (!this.baseline || this.history.length < 2) {\n      return { avgDrift: 0, maxDrift: 0, driftEvents: 0 };\n    }\n\n    const drifts = this.history.map(h => 1 - cosineSimilarity(this.baseline!, h.embedding));\n    const avgDrift = drifts.reduce((a, b) => a + b, 0) / drifts.length;\n    const maxDrift = Math.max(...drifts);\n    const driftEvents = drifts.filter(d => d > this.driftThreshold).length;\n\n    return { avgDrift, maxDrift, driftEvents };\n  }\n}\n\n/**\n * Memory Physics\n * Hippocampal-like dynamics: decay, interference, consolidation\n */\nexport class MemoryPhysics {\n  private embedder = getOptimizedEmbedder();\n  private memories: Map<string, MemoryEntry> = new Map();\n  private lastConsolidation = Date.now();\n\n  constructor(\n    private decayRate = 0.01,\n    private interferenceRadius = 0.3,\n    private forgettingThreshold = 0.1\n  ) {}\n\n  async init() {\n    await this.embedder.init();\n  }\n\n  async store(id: string, content: string): Promise<{ stored: boolean; interference: string[] }> {\n    validateId(id, 'MemoryPhysics.store');\n    validateTextInput(content, 'MemoryPhysics.store');\n\n    // Security: Enforce memory limit\n    if (this.memories.size >= MAX_MEMORIES && !this.memories.has(id)) {\n      throw new Error(`Memory capacity exceeded (max: ${MAX_MEMORIES}). Call consolidate() to free space.`);\n    }\n\n    const embedding = await this.embedder.embed(content);\n    const interference: string[] = [];\n\n    // Check interference with existing memories\n    for (const [memId, mem] of this.memories) {\n      const distance = euclideanDistance(embedding, mem.embedding);\n      if (distance < this.interferenceRadius) {\n        const strength = (this.interferenceRadius - distance) / this.interferenceRadius;\n        mem.strength *= (1 - strength * 0.5);\n        interference.push(memId);\n      }\n    }\n\n    this.memories.set(id, {\n      id,\n      embedding,\n      content,\n      strength: 1.0,\n      timestamp: Date.now(),\n      accessCount: 0,\n      associations: interference\n    });\n\n    return { stored: true, interference };\n  }\n\n  async recall(query: string, topK = 5): Promise<Array<MemoryEntry & { relevance: number }>> {\n    validateTextInput(query, 'MemoryPhysics.recall');\n\n    const queryEmb = await this.embedder.embed(query);\n    this.applyDecay();\n\n    const results: Array<MemoryEntry & { relevance: number }> = [];\n\n    for (const mem of this.memories.values()) {\n      if (mem.strength < this.forgettingThreshold) continue;\n\n      const relevance = cosineSimilarity(queryEmb, mem.embedding);\n      mem.accessCount++;\n      mem.strength = Math.min(1.0, mem.strength * 1.1); // Retrieval strengthens\n\n      results.push({ ...mem, relevance });\n    }\n\n    return results\n      .sort((a, b) => (b.relevance * b.strength) - (a.relevance * a.strength))\n      .slice(0, topK);\n  }\n\n  private applyDecay() {\n    const now = Date.now();\n    for (const mem of this.memories.values()) {\n      const hours = (now - mem.timestamp) / 3600000;\n      mem.strength *= Math.exp(-this.decayRate * hours);\n      mem.timestamp = now;\n    }\n  }\n\n  consolidate(): { merged: number; forgotten: number; remaining: number } {\n    const clusters: MemoryEntry[][] = [];\n    const used = new Set<string>();\n    let merged = 0;\n    let forgotten = 0;\n\n    // Remove forgotten memories\n    for (const [id, mem] of this.memories) {\n      if (mem.strength < this.forgettingThreshold) {\n        this.memories.delete(id);\n        forgotten++;\n      }\n    }\n\n    // Cluster similar memories\n    for (const mem of this.memories.values()) {\n      if (used.has(mem.id)) continue;\n\n      const cluster = [mem];\n      for (const other of this.memories.values()) {\n        if (used.has(other.id) || mem.id === other.id) continue;\n\n        const sim = cosineSimilarity(mem.embedding, other.embedding);\n        if (sim > 0.9) {\n          cluster.push(other);\n          used.add(other.id);\n          merged++;\n        }\n      }\n\n      if (cluster.length > 1) {\n        // Merge: keep strongest, combine strength\n        const strongest = cluster.reduce((a, b) => a.strength > b.strength ? a : b);\n        strongest.strength = Math.min(1.0, cluster.reduce((s, m) => s + m.strength, 0));\n        strongest.associations = [...new Set(cluster.flatMap(c => c.associations))];\n\n        for (const c of cluster) {\n          if (c.id !== strongest.id) this.memories.delete(c.id);\n        }\n      }\n\n      clusters.push(cluster);\n    }\n\n    this.lastConsolidation = Date.now();\n    return { merged, forgotten, remaining: this.memories.size };\n  }\n\n  getStats(): { total: number; active: number; avgStrength: number } {\n    const active = [...this.memories.values()].filter(m => m.strength > this.forgettingThreshold);\n    const avgStrength = active.length > 0\n      ? active.reduce((s, m) => s + m.strength, 0) / active.length\n      : 0;\n\n    return {\n      total: this.memories.size,\n      active: active.length,\n      avgStrength\n    };\n  }\n}\n\n/**\n * Embedding State Machine\n * Agent state through geometry: position, velocity, attention\n */\nexport class EmbeddingStateMachine {\n  private embedder = getOptimizedEmbedder();\n  private agents: Map<string, AgentState> = new Map();\n  private stateRegions: Map<string, Float32Array> = new Map();\n\n  constructor(private dimension = 384) {}\n\n  async init() {\n    await this.embedder.init();\n\n    // Initialize default state regions\n    const regions = {\n      exploring: 'exploring options, gathering information, uncertain, searching',\n      executing: 'executing task, confident, taking action, progressing',\n      waiting: 'waiting for input, paused, blocked, need information',\n      error: 'error state, confused, failed, need help, recovery'\n    };\n\n    for (const [name, desc] of Object.entries(regions)) {\n      this.stateRegions.set(name, await this.embedder.embed(desc));\n    }\n  }\n\n  async registerAgent(id: string, initialRole: string): Promise<AgentState> {\n    validateId(id, 'EmbeddingStateMachine.registerAgent');\n    validateTextInput(initialRole, 'EmbeddingStateMachine.registerAgent');\n\n    // Security: Enforce agent limit\n    if (this.agents.size >= MAX_AGENTS && !this.agents.has(id)) {\n      throw new Error(`Agent capacity exceeded (max: ${MAX_AGENTS})`);\n    }\n\n    const position = await this.embedder.embed(initialRole);\n    const state: AgentState = {\n      id,\n      position,\n      velocity: new Float32Array(this.dimension).fill(0),\n      attention: new Float32Array(this.dimension).fill(1),\n      energy: 1.0,\n      lastUpdate: Date.now()\n    };\n\n    this.agents.set(id, state);\n    return state;\n  }\n\n  async updateState(agentId: string, observation: string): Promise<{\n    newState: AgentState;\n    nearestRegion: string;\n    regionProximity: number;\n  }> {\n    validateId(agentId, 'EmbeddingStateMachine.updateState');\n    validateTextInput(observation, 'EmbeddingStateMachine.updateState');\n\n    const agent = this.agents.get(agentId);\n    if (!agent) throw new Error('Agent not found or access denied');\n\n    const obsEmb = await this.embedder.embed(observation);\n\n    // Update velocity and position\n    const learningRate = 0.3;\n    const momentumRate = 0.7;\n\n    for (let i = 0; i < this.dimension; i++) {\n      const gradient = obsEmb[i] - agent.position[i];\n      agent.velocity[i] = momentumRate * agent.velocity[i] + learningRate * gradient;\n      agent.position[i] += agent.velocity[i];\n    }\n\n    // Normalize position\n    const norm = Math.sqrt(agent.position.reduce((s, v) => s + v * v, 0));\n    for (let i = 0; i < this.dimension; i++) {\n      agent.position[i] /= norm;\n    }\n\n    // Update attention based on velocity magnitude\n    const velocityMag = Math.sqrt(agent.velocity.reduce((s, v) => s + v * v, 0));\n    for (let i = 0; i < this.dimension; i++) {\n      agent.attention[i] = 1 + velocityMag * Math.abs(agent.velocity[i]);\n    }\n\n    // Energy decay with movement\n    agent.energy = Math.max(0.1, agent.energy - velocityMag * 0.1);\n    agent.lastUpdate = Date.now();\n\n    // Find nearest state region\n    let nearestRegion = 'unknown';\n    let regionProximity = -1;\n\n    for (const [name, region] of this.stateRegions) {\n      const sim = cosineSimilarity(agent.position, region);\n      if (sim > regionProximity) {\n        regionProximity = sim;\n        nearestRegion = name;\n      }\n    }\n\n    return { newState: agent, nearestRegion, regionProximity };\n  }\n\n  getAgent(id: string): AgentState | undefined {\n    return this.agents.get(id);\n  }\n\n  getAllAgents(): AgentState[] {\n    return [...this.agents.values()];\n  }\n}\n\n/**\n * Swarm Coordinator\n * Multi-agent coordination through shared embedding space\n */\nexport class SwarmCoordinator {\n  private embedder = getOptimizedEmbedder();\n  private stateMachine: EmbeddingStateMachine;\n\n  constructor(dimension = 384) {\n    this.stateMachine = new EmbeddingStateMachine(dimension);\n  }\n\n  async init() {\n    await this.embedder.init();\n    await this.stateMachine.init();\n  }\n\n  async addAgent(id: string, role: string) {\n    validateId(id, 'SwarmCoordinator.addAgent');\n    validateTextInput(role, 'SwarmCoordinator.addAgent');\n\n    return this.stateMachine.registerAgent(id, role);\n  }\n\n  async coordinate(task: string): Promise<Array<{\n    agentId: string;\n    taskAlignment: number;\n    bestCollaborator: string | null;\n    collaborationScore: number;\n  }>> {\n    const taskEmb = await this.embedder.embed(task);\n    const agents = this.stateMachine.getAllAgents();\n    const results: Array<{\n      agentId: string;\n      taskAlignment: number;\n      bestCollaborator: string | null;\n      collaborationScore: number;\n    }> = [];\n\n    for (const agent of agents) {\n      const taskAlignment = cosineSimilarity(agent.position, taskEmb);\n\n      // Find best collaborator\n      let bestCollaborator: string | null = null;\n      let bestScore = -1;\n\n      for (const other of agents) {\n        if (other.id === agent.id) continue;\n\n        const otherAlignment = cosineSimilarity(other.position, taskEmb);\n        const complementarity = 1 - cosineSimilarity(agent.position, other.position);\n        const score = otherAlignment * 0.6 + complementarity * 0.4;\n\n        if (score > bestScore) {\n          bestScore = score;\n          bestCollaborator = other.id;\n        }\n      }\n\n      results.push({\n        agentId: agent.id,\n        taskAlignment,\n        bestCollaborator,\n        collaborationScore: bestScore\n      });\n    }\n\n    return results.sort((a, b) => b.taskAlignment - a.taskAlignment);\n  }\n\n  specialize(): void {\n    const agents = this.stateMachine.getAllAgents();\n    const repulsionStrength = 0.05;\n\n    for (let i = 0; i < agents.length; i++) {\n      for (let j = i + 1; j < agents.length; j++) {\n        const sim = cosineSimilarity(agents[i].position, agents[j].position);\n        if (sim > 0.8) {\n          // Repel similar agents\n          for (let k = 0; k < agents[i].position.length; k++) {\n            const repulsion = repulsionStrength * (agents[j].position[k] - agents[i].position[k]);\n            agents[i].position[k] -= repulsion;\n            agents[j].position[k] += repulsion;\n          }\n        }\n      }\n    }\n\n    // Normalize all\n    for (const agent of agents) {\n      const norm = Math.sqrt(agent.position.reduce((s, v) => s + v * v, 0));\n      for (let k = 0; k < agent.position.length; k++) {\n        agent.position[k] /= norm;\n      }\n    }\n  }\n\n  getStatus(): { agentCount: number; avgEnergy: number; coherence: number } {\n    const agents = this.stateMachine.getAllAgents();\n    if (agents.length === 0) return { agentCount: 0, avgEnergy: 0, coherence: 0 };\n\n    const avgEnergy = agents.reduce((s, a) => s + a.energy, 0) / agents.length;\n\n    // Coherence = average pairwise similarity\n    let coherence = 0;\n    let pairs = 0;\n    for (let i = 0; i < agents.length; i++) {\n      for (let j = i + 1; j < agents.length; j++) {\n        coherence += cosineSimilarity(agents[i].position, agents[j].position);\n        pairs++;\n      }\n    }\n    coherence = pairs > 0 ? coherence / pairs : 1;\n\n    return { agentCount: agents.length, avgEnergy, coherence };\n  }\n}\n\n/**\n * Coherence Monitor\n * Safety and alignment detection\n */\nexport class CoherenceMonitor {\n  private embedder = getOptimizedEmbedder();\n  private baseline: Float32Array[] = [];\n  private centroid: Float32Array | null = null;\n  private avgDistance = 0;\n\n  async init() {\n    await this.embedder.init();\n  }\n\n  async calibrate(goodOutputs: string[]): Promise<{ calibrated: boolean; sampleCount: number }> {\n    // Security: Validate input array\n    if (!Array.isArray(goodOutputs)) {\n      throw new Error('CoherenceMonitor.calibrate: goodOutputs must be an array');\n    }\n    if (goodOutputs.length === 0) {\n      throw new Error('CoherenceMonitor.calibrate: At least one sample is required');\n    }\n    if (goodOutputs.length > MAX_BASELINE_SAMPLES) {\n      throw new Error(`CoherenceMonitor.calibrate: Sample count exceeds maximum of ${MAX_BASELINE_SAMPLES}`);\n    }\n\n    // Validate each sample\n    for (const output of goodOutputs) {\n      validateTextInput(output, 'CoherenceMonitor.calibrate');\n    }\n\n    this.baseline = await this.embedder.embedBatch(goodOutputs);\n    const dim = this.baseline[0].length;\n\n    // Calculate centroid\n    this.centroid = new Float32Array(dim).fill(0);\n    for (const emb of this.baseline) {\n      for (let i = 0; i < dim; i++) {\n        this.centroid[i] += emb[i];\n      }\n    }\n    for (let i = 0; i < dim; i++) {\n      this.centroid[i] /= this.baseline.length;\n    }\n\n    // Average distance from centroid\n    this.avgDistance = this.baseline.reduce((s, b) =>\n      s + euclideanDistance(b, this.centroid!), 0\n    ) / this.baseline.length;\n\n    return { calibrated: true, sampleCount: this.baseline.length };\n  }\n\n  async check(output: string): Promise<CoherenceResult> {\n    validateTextInput(output, 'CoherenceMonitor.check');\n    validateEmbedding(this.centroid, 'CoherenceMonitor.check (call calibrate() first)');\n\n    const outputEmb = await this.embedder.embed(output);\n    const warnings: string[] = [];\n\n    // Anomaly score\n    const distance = euclideanDistance(outputEmb, this.centroid);\n    const anomalyScore = distance / this.avgDistance;\n\n    // Nearest neighbor\n    let maxSim = -1;\n    for (const b of this.baseline) {\n      const sim = cosineSimilarity(outputEmb, b);\n      if (sim > maxSim) maxSim = sim;\n    }\n    const stabilityScore = maxSim;\n\n    // Drift direction\n    const driftDirection = new Float32Array(outputEmb.length);\n    for (let i = 0; i < outputEmb.length; i++) {\n      driftDirection[i] = outputEmb[i] - this.centroid[i];\n    }\n\n    // Warnings\n    if (anomalyScore > 2.0) {\n      warnings.push('CRITICAL: Output significantly outside baseline');\n    } else if (anomalyScore > 1.5) {\n      warnings.push('WARNING: Output drifting from baseline');\n    }\n\n    if (stabilityScore < 0.5) {\n      warnings.push('WARNING: Low similarity to all baseline examples');\n    }\n\n    return {\n      isCoherent: anomalyScore < 1.5 && stabilityScore > 0.5,\n      anomalyScore,\n      stabilityScore,\n      driftDirection,\n      warnings\n    };\n  }\n}\n\n/**\n * Neural Substrate\n * Unified nervous system combining all components\n */\nexport class NeuralSubstrate {\n  public drift: SemanticDriftDetector;\n  public memory: MemoryPhysics;\n  public states: EmbeddingStateMachine;\n  public swarm: SwarmCoordinator;\n  public coherence: CoherenceMonitor;\n\n  private startTime = Date.now();\n\n  constructor(config: {\n    dimension?: number;\n    driftThreshold?: number;\n    decayRate?: number;\n  } = {}) {\n    const { dimension = 384, driftThreshold = 0.15, decayRate = 0.01 } = config;\n\n    this.drift = new SemanticDriftDetector(driftThreshold);\n    this.memory = new MemoryPhysics(decayRate);\n    this.states = new EmbeddingStateMachine(dimension);\n    this.swarm = new SwarmCoordinator(dimension);\n    this.coherence = new CoherenceMonitor();\n  }\n\n  async init() {\n    await Promise.all([\n      this.drift.init(),\n      this.memory.init(),\n      this.states.init(),\n      this.swarm.init(),\n      this.coherence.init()\n    ]);\n  }\n\n  async process(input: string, context?: {\n    agentId?: string;\n    memoryId?: string;\n    checkCoherence?: boolean;\n  }): Promise<{\n    drift: DriftResult;\n    state?: { nearestRegion: string; regionProximity: number };\n    coherence?: CoherenceResult;\n    stored?: boolean;\n  }> {\n    const result: any = {};\n\n    // Always check drift\n    result.drift = await this.drift.detect(input);\n\n    // Update agent state if specified\n    if (context?.agentId) {\n      const { nearestRegion, regionProximity } = await this.states.updateState(\n        context.agentId,\n        input\n      );\n      result.state = { nearestRegion, regionProximity };\n    }\n\n    // Store in memory if specified\n    if (context?.memoryId) {\n      const { stored } = await this.memory.store(context.memoryId, input);\n      result.stored = stored;\n    }\n\n    // Check coherence if requested\n    if (context?.checkCoherence) {\n      result.coherence = await this.coherence.check(input);\n    }\n\n    return result;\n  }\n\n  consolidate(): { memory: ReturnType<MemoryPhysics['consolidate']> } {\n    return { memory: this.memory.consolidate() };\n  }\n\n  health(): SubstrateHealth {\n    const memStats = this.memory.getStats();\n    const driftStats = this.drift.getStats();\n    const swarmStatus = this.swarm.getStatus();\n\n    return {\n      memoryCount: memStats.total,\n      activeAgents: swarmStatus.agentCount,\n      avgDrift: driftStats.avgDrift,\n      avgCoherence: swarmStatus.coherence,\n      lastConsolidation: 0, // Would need to track this\n      uptime: Date.now() - this.startTime\n    };\n  }\n}\n\n// Export singleton factory\nlet substrate: NeuralSubstrate | null = null;\n\nexport async function getNeuralSubstrate(config?: {\n  dimension?: number;\n  driftThreshold?: number;\n  decayRate?: number;\n}): Promise<NeuralSubstrate> {\n  if (!substrate) {\n    substrate = new NeuralSubstrate(config);\n    await substrate.init();\n  }\n  return substrate;\n}\n"]}