{"version":3,"file":"metrics.js","sourceRoot":"","sources":["../../../../../src/mcp/fastmcp/tools/hooks/metrics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Metrics Hook - Learning dashboard and performance metrics\n */\n\nimport { z } from 'zod';\nimport type { ToolDefinition } from '../../types/index.js';\nimport { loadIntelligence } from './shared.js';\n\nexport const hookMetricsTool: ToolDefinition = {\n  name: 'hook_metrics',\n  description: 'Get learning metrics and performance dashboard',\n  parameters: z.object({\n    timeframe: z.enum(['1h', '24h', '7d', '30d']).optional().default('24h'),\n    detailed: z.boolean().optional().default(false)\n  }),\n  execute: async ({ timeframe, detailed }, { onProgress }) => {\n    const startTime = Date.now();\n    const intel = loadIntelligence();\n\n    // Parse timeframe\n    const timeMs: Record<string, number> = {\n      '1h': 60 * 60 * 1000,\n      '24h': 24 * 60 * 60 * 1000,\n      '7d': 7 * 24 * 60 * 60 * 1000,\n      '30d': 30 * 24 * 60 * 60 * 1000\n    };\n\n    const cutoff = Date.now() - timeMs[timeframe];\n\n    // Filter routing history by timeframe\n    const recentHistory = intel.metrics.routingHistory.filter(\n      h => new Date(h.timestamp).getTime() > cutoff\n    );\n\n    // Calculate routing accuracy\n    const successCount = recentHistory.filter(h => h.success).length;\n    const routingAccuracy = recentHistory.length > 0\n      ? successCount / recentHistory.length\n      : 0;\n\n    // Calculate per-agent performance\n    const agentPerformance: Record<string, {\n      total: number;\n      successful: number;\n      rate: number;\n    }> = {};\n\n    for (const entry of recentHistory) {\n      if (!agentPerformance[entry.agent]) {\n        agentPerformance[entry.agent] = { total: 0, successful: 0, rate: 0 };\n      }\n      agentPerformance[entry.agent].total++;\n      if (entry.success) {\n        agentPerformance[entry.agent].successful++;\n      }\n    }\n\n    // Calculate rates\n    for (const agent of Object.keys(agentPerformance)) {\n      const perf = agentPerformance[agent];\n      perf.rate = perf.total > 0 ? perf.successful / perf.total : 0;\n    }\n\n    // Get top patterns\n    const patternStats: Array<{\n      state: string;\n      agents: Record<string, number>;\n      topAgent: string;\n      topScore: number;\n    }> = [];\n\n    for (const [state, agents] of Object.entries(intel.patterns)) {\n      const agentScores = agents as Record<string, number>;\n      let topAgent = '';\n      let topScore = 0;\n\n      for (const [agent, score] of Object.entries(agentScores)) {\n        if (score > topScore) {\n          topScore = score;\n          topAgent = agent;\n        }\n      }\n\n      patternStats.push({\n        state,\n        agents: agentScores,\n        topAgent,\n        topScore\n      });\n    }\n\n    patternStats.sort((a, b) => b.topScore - a.topScore);\n\n    // Calculate learning velocity (improvement trend)\n    let learningVelocity = 0;\n    if (recentHistory.length >= 10) {\n      const firstHalf = recentHistory.slice(0, Math.floor(recentHistory.length / 2));\n      const secondHalf = recentHistory.slice(Math.floor(recentHistory.length / 2));\n\n      const firstHalfRate = firstHalf.filter(h => h.success).length / firstHalf.length;\n      const secondHalfRate = secondHalf.filter(h => h.success).length / secondHalf.length;\n\n      learningVelocity = secondHalfRate - firstHalfRate;\n    }\n\n    // Memory utilization\n    const memoryStats = {\n      total: intel.memories.length,\n      byType: {} as Record<string, number>\n    };\n\n    for (const mem of intel.memories) {\n      memoryStats.byType[mem.type] = (memoryStats.byType[mem.type] || 0) + 1;\n    }\n\n    // Error pattern analysis\n    const errorStats = {\n      total: intel.errorPatterns.length,\n      topErrors: intel.errorPatterns\n        .map(ep => ({\n          type: ep.errorType,\n          context: ep.context.slice(0, 50),\n          occurrences: Object.values(ep.agentSuccess).reduce((a, b) => Math.abs(a) + Math.abs(b), 0)\n        }))\n        .sort((a, b) => b.occurrences - a.occurrences)\n        .slice(0, 5)\n    };\n\n    const latency = Date.now() - startTime;\n\n    return {\n      success: true,\n      timeframe,\n      routing: {\n        accuracy: routingAccuracy,\n        total: recentHistory.length,\n        successful: successCount,\n        failed: recentHistory.length - successCount\n      },\n      learning: {\n        velocity: learningVelocity,\n        improving: learningVelocity > 0,\n        patternsLearned: Object.keys(intel.patterns).length,\n        memoriesStored: intel.memories.length\n      },\n      agents: detailed ? agentPerformance : Object.fromEntries(\n        Object.entries(agentPerformance)\n          .sort((a, b) => b[1].total - a[1].total)\n          .slice(0, 5)\n      ),\n      topPatterns: patternStats.slice(0, detailed ? 10 : 5).map(p => ({\n        state: p.state,\n        topAgent: p.topAgent,\n        score: p.topScore.toFixed(2)\n      })),\n      memory: memoryStats,\n      errors: errorStats,\n      pretrained: intel.pretrained || null,\n      health: {\n        status: routingAccuracy > 0.7 ? 'healthy' : routingAccuracy > 0.5 ? 'learning' : 'needs-data',\n        dataPoints: recentHistory.length,\n        recommendation: recentHistory.length < 10\n          ? 'Need more data points for accurate metrics'\n          : learningVelocity < 0\n            ? 'Learning velocity negative - consider retraining'\n            : 'System learning effectively'\n      },\n      latencyMs: latency,\n      timestamp: new Date().toISOString()\n    };\n  }\n};\n"]}