{"version":3,"file":"post-command.js","sourceRoot":"","sources":["../../../../../src/mcp/fastmcp/tools/hooks/post-command.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAExB,OAAO,EACL,gBAAgB,EAChB,gBAAgB,EAChB,WAAW,EACZ,MAAM,aAAa,CAAC;AAErB,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B,MAAM,CAAC,MAAM,mBAAmB,GAAmB;IACjD,IAAI,EAAE,mBAAmB;IACzB,WAAW,EAAE,6DAA6D;IAC1E,UAAU,EAAE,CAAC,CAAC,MAAM,CAAC;QACnB,OAAO,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,2BAA2B,CAAC;QACzD,QAAQ,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,mBAAmB,CAAC;QAClD,MAAM,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,uBAAuB,CAAC;QAC/D,MAAM,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,6BAA6B,CAAC;KACtE,CAAC;IACF,OAAO,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,UAAU,EAAE,EAAE,EAAE;QACvE,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC7B,MAAM,KAAK,GAAG,gBAAgB,EAAE,CAAC;QACjC,MAAM,OAAO,GAAG,QAAQ,KAAK,CAAC,CAAC;QAC/B,MAAM,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,MAAM,KAAK,GAAG,WAAW,OAAO,EAAE,CAAC;QAEnC,6BAA6B;QAC7B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YAC3B,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;QAC7B,CAAC;QAED,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC;QAC/C,MAAM,YAAY,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACxD,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAEpC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,GAAG,YAAY,GAAG,aAAa,GAAG,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;QAEvF,yBAAyB;QACzB,IAAI,YAAY,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC,OAAO,IAAI,MAAM,EAAE,CAAC;YACvB,iCAAiC;YACjC,MAAM,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC,6DAA6D,CAAC,CAAC;YAC/F,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC;YAE9D,6BAA6B;YAC7B,MAAM,QAAQ,GAAG,KAAK,CAAC,aAAa,CAAC,IAAI,CACvC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,KAAK,SAAS,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAC9D,CAAC;YAEF,IAAI,QAAQ,EAAE,CAAC;gBACb,0BAA0B;gBAC1B,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;YACjF,CAAC;iBAAM,CAAC;gBACN,2BAA2B;gBAC3B,YAAY,GAAG;oBACb,SAAS;oBACT,OAAO,EAAE,GAAG,OAAO,aAAa,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;oBACtD,UAAU,EAAE,EAAE,EAAE,+BAA+B;oBAC/C,YAAY,EAAE,EAAE,SAAS,EAAE,CAAC,EAAE;iBAC/B,CAAC;gBACF,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACzC,CAAC;YAED,8BAA8B;YAC9B,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,GAAG,EAAE,EAAE,CAAC;gBACpC,KAAK,CAAC,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;YACvD,CAAC;QACH,CAAC;QAED,yDAAyD;QACzD,IAAI,OAAO,IAAI,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,EAAE,EAAE,CAAC;YAC5C,MAAM,aAAa,GAAG,YAAY,OAAO,gBAAgB,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC;YAChF,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC;gBAClB,OAAO,EAAE,aAAa;gBACtB,IAAI,EAAE,SAAS;gBACf,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;gBACjC,SAAS,EAAE,WAAW,CAAC,aAAa,CAAC;aACtC,CAAC,CAAC;YAEH,yBAAyB;YACzB,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;gBAChC,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;YAC9C,CAAC;QACH,CAAC;QAED,oBAAoB;QACpB,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;QAC5B,IAAI,OAAO,EAAE,CAAC;YACZ,KAAK,CAAC,OAAO,CAAC,gBAAgB,EAAE,CAAC;QACnC,CAAC;QAED,uBAAuB;QACvB,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAExB,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;QAEvC,OAAO;YACL,OAAO,EAAE,IAAI;YACb,OAAO,EAAE,IAAI;YACb,cAAc,EAAE,OAAO;YACvB,SAAS,EAAE,YAAY,EAAE,SAAS,IAAI,IAAI;YAC1C,YAAY,EAAE,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;YAC3C,SAAS,EAAE,OAAO;YAClB,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;SACpC,CAAC;IACJ,CAAC;CACF,CAAC","sourcesContent":["/**\n * Post-Command Hook - Learn from command outcomes\n * Records command results and learns from errors\n */\n\nimport { z } from 'zod';\nimport type { ToolDefinition } from '../../types/index.js';\nimport {\n  loadIntelligence,\n  saveIntelligence,\n  simpleEmbed\n} from './shared.js';\n\nconst LEARNING_RATE = 0.1;\n\nexport const hookPostCommandTool: ToolDefinition = {\n  name: 'hook_post_command',\n  description: 'Post-command learning: record outcome and learn from errors',\n  parameters: z.object({\n    command: z.string().describe('Command that was executed'),\n    exitCode: z.number().describe('Command exit code'),\n    stderr: z.string().optional().describe('Standard error output'),\n    stdout: z.string().optional().describe('Standard output (truncated)')\n  }),\n  execute: async ({ command, exitCode, stderr, stdout }, { onProgress }) => {\n    const startTime = Date.now();\n    const intel = loadIntelligence();\n    const success = exitCode === 0;\n    const cmdBase = command.split(' ')[0];\n    const state = `command:${cmdBase}`;\n\n    // 1. Update command patterns\n    if (!intel.patterns[state]) {\n      intel.patterns[state] = {};\n    }\n\n    const action = success ? 'success' : 'failure';\n    const currentValue = intel.patterns[state][action] || 0;\n    const reward = success ? 1.0 : -0.5;\n\n    intel.patterns[state][action] = currentValue + LEARNING_RATE * (reward - currentValue);\n\n    // 2. Learn from failures\n    let errorPattern = null;\n    if (!success && stderr) {\n      // Extract error type from stderr\n      const errorMatch = stderr.match(/^(\\w+Error|\\w+Exception|error\\[\\w+\\]|ENOENT|EACCES|EPERM)/im);\n      const errorType = errorMatch ? errorMatch[1] : 'CommandError';\n\n      // Check for existing pattern\n      const existing = intel.errorPatterns.find(\n        p => p.errorType === errorType && p.context.includes(cmdBase)\n      );\n\n      if (existing) {\n        // Update existing pattern\n        existing.agentSuccess['command'] = (existing.agentSuccess['command'] || 0) + 1;\n      } else {\n        // Create new error pattern\n        errorPattern = {\n          errorType,\n          context: `${cmdBase} command: ${stderr.slice(0, 100)}`,\n          resolution: '', // Will be filled when resolved\n          agentSuccess: { 'command': 1 }\n        };\n        intel.errorPatterns.push(errorPattern);\n      }\n\n      // Keep last 50 error patterns\n      if (intel.errorPatterns.length > 50) {\n        intel.errorPatterns = intel.errorPatterns.slice(-50);\n      }\n    }\n\n    // 3. Store successful command as memory if useful output\n    if (success && stdout && stdout.length > 10) {\n      const memoryContent = `Command \"${cmdBase}\" succeeded: ${stdout.slice(0, 100)}`;\n      intel.memories.push({\n        content: memoryContent,\n        type: 'command',\n        created: new Date().toISOString(),\n        embedding: simpleEmbed(memoryContent)\n      });\n\n      // Keep last 200 memories\n      if (intel.memories.length > 200) {\n        intel.memories = intel.memories.slice(-200);\n      }\n    }\n\n    // 4. Update metrics\n    intel.metrics.totalRoutes++;\n    if (success) {\n      intel.metrics.successfulRoutes++;\n    }\n\n    // 5. Save intelligence\n    saveIntelligence(intel);\n\n    const latency = Date.now() - startTime;\n\n    return {\n      success: true,\n      learned: true,\n      commandSuccess: success,\n      errorType: errorPattern?.errorType || null,\n      patternValue: intel.patterns[state][action],\n      latencyMs: latency,\n      timestamp: new Date().toISOString()\n    };\n  }\n};\n"]}