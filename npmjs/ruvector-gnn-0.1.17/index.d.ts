/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Compression level for tensor compression */
export interface CompressionLevelConfig {
  /** Type of compression: "none", "half", "pq8", "pq4", "binary" */
  levelType: string
  /** Scale factor (for "half" compression) */
  scale?: number
  /** Number of subvectors (for PQ compression) */
  subvectors?: number
  /** Number of centroids (for PQ8) */
  centroids?: number
  /** Outlier threshold (for PQ4) */
  outlierThreshold?: number
  /** Binary threshold (for binary compression) */
  threshold?: number
}
/** Result from differentiable search */
export interface SearchResult {
  /** Indices of top-k candidates */
  indices: Array<number>
  /** Soft weights for top-k candidates */
  weights: Array<number>
}
/**
 * Differentiable search using soft attention mechanism
 *
 * # Arguments
 * * `query` - The query vector
 * * `candidate_embeddings` - List of candidate embedding vectors
 * * `k` - Number of top results to return
 * * `temperature` - Temperature for softmax (lower = sharper, higher = smoother)
 *
 * # Returns
 * Search result with indices and soft weights
 *
 * # Example
 * ```javascript
 * const query = [1.0, 0.0, 0.0];
 * const candidates = [[1.0, 0.0, 0.0], [0.9, 0.1, 0.0], [0.0, 1.0, 0.0]];
 * const result = differentiableSearch(query, candidates, 2, 1.0);
 * console.log(result.indices); // [0, 1]
 * console.log(result.weights); // [0.x, 0.y]
 * ```
 */
export declare function differentiableSearch(query: Array<number>, candidateEmbeddings: Array<Array<number>>, k: number, temperature: number): SearchResult
/**
 * Hierarchical forward pass through GNN layers
 *
 * # Arguments
 * * `query` - The query vector
 * * `layer_embeddings` - Embeddings organized by layer
 * * `gnn_layers_json` - JSON array of serialized GNN layers
 *
 * # Returns
 * Final embedding after hierarchical processing
 *
 * # Example
 * ```javascript
 * const query = [1.0, 0.0];
 * const layerEmbeddings = [[[1.0, 0.0], [0.0, 1.0]]];
 * const layer1 = new RuvectorLayer(2, 2, 1, 0.0);
 * const layers = [layer1.toJson()];
 * const result = hierarchicalForward(query, layerEmbeddings, layers);
 * ```
 */
export declare function hierarchicalForward(query: Array<number>, layerEmbeddings: Array<Array<Array<number>>>, gnnLayersJson: Array<string>): Array<number>
/**
 * Get the compression level that would be selected for a given access frequency
 *
 * # Arguments
 * * `access_freq` - Access frequency in range [0.0, 1.0]
 *
 * # Returns
 * String describing the compression level: "none", "half", "pq8", "pq4", or "binary"
 *
 * # Example
 * ```javascript
 * const level = getCompressionLevel(0.9); // "none" (hot data)
 * const level2 = getCompressionLevel(0.5); // "half" (warm data)
 * ```
 */
export declare function getCompressionLevel(accessFreq: number): string
/** Module initialization */
export declare function init(): string
/** Graph Neural Network layer for HNSW topology */
export declare class RuvectorLayer {
  /**
   * Create a new Ruvector GNN layer
   *
   * # Arguments
   * * `input_dim` - Dimension of input node embeddings
   * * `hidden_dim` - Dimension of hidden representations
   * * `heads` - Number of attention heads
   * * `dropout` - Dropout rate (0.0 to 1.0)
   *
   * # Example
   * ```javascript
   * const layer = new RuvectorLayer(128, 256, 4, 0.1);
   * ```
   */
  constructor(inputDim: number, hiddenDim: number, heads: number, dropout: number)
  /**
   * Forward pass through the GNN layer
   *
   * # Arguments
   * * `node_embedding` - Current node's embedding
   * * `neighbor_embeddings` - Embeddings of neighbor nodes
   * * `edge_weights` - Weights of edges to neighbors
   *
   * # Returns
   * Updated node embedding
   *
   * # Example
   * ```javascript
   * const node = [1.0, 2.0, 3.0, 4.0];
   * const neighbors = [[0.5, 1.0, 1.5, 2.0], [2.0, 3.0, 4.0, 5.0]];
   * const weights = [0.3, 0.7];
   * const output = layer.forward(node, neighbors, weights);
   * ```
   */
  forward(nodeEmbedding: Array<number>, neighborEmbeddings: Array<Array<number>>, edgeWeights: Array<number>): Array<number>
  /** Serialize the layer to JSON */
  toJson(): string
  /** Deserialize the layer from JSON */
  static fromJson(json: string): RuvectorLayer
}
/** Tensor compressor with adaptive level selection */
export declare class TensorCompress {
  /**
   * Create a new tensor compressor
   *
   * # Example
   * ```javascript
   * const compressor = new TensorCompress();
   * ```
   */
  constructor()
  /**
   * Compress an embedding based on access frequency
   *
   * # Arguments
   * * `embedding` - The input embedding vector
   * * `access_freq` - Access frequency in range [0.0, 1.0]
   *
   * # Returns
   * Compressed tensor as JSON string
   *
   * # Example
   * ```javascript
   * const embedding = [1.0, 2.0, 3.0, 4.0];
   * const compressed = compressor.compress(embedding, 0.5);
   * ```
   */
  compress(embedding: Array<number>, accessFreq: number): string
  /**
   * Compress with explicit compression level
   *
   * # Arguments
   * * `embedding` - The input embedding vector
   * * `level` - Compression level configuration
   *
   * # Returns
   * Compressed tensor as JSON string
   *
   * # Example
   * ```javascript
   * const embedding = [1.0, 2.0, 3.0, 4.0];
   * const level = { level_type: "half", scale: 1.0 };
   * const compressed = compressor.compressWithLevel(embedding, level);
   * ```
   */
  compressWithLevel(embedding: Array<number>, level: CompressionLevelConfig): string
  /**
   * Decompress a compressed tensor
   *
   * # Arguments
   * * `compressed_json` - Compressed tensor as JSON string
   *
   * # Returns
   * Decompressed embedding vector
   *
   * # Example
   * ```javascript
   * const decompressed = compressor.decompress(compressed);
   * ```
   */
  decompress(compressedJson: string): Array<number>
}
