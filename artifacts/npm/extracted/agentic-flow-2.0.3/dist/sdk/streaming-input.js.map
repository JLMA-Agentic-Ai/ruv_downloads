{"version":3,"file":"streaming-input.js","sourceRoot":"","sources":["../../src/sdk/streaming-input.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Streaming Input Mode - Stream prompts as async iterables\n *\n * Enables streaming prompts to the SDK, allowing:\n * - Multi-turn conversations without separate query calls\n * - Interactive user input during execution\n * - Pipeline-style prompt processing\n */\n\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * SDK User Message format\n */\nexport interface SDKUserMessage {\n  type: 'user';\n  message: {\n    content: Array<{\n      type: 'text';\n      text: string;\n    } | {\n      type: 'image';\n      source: {\n        type: 'base64';\n        media_type: string;\n        data: string;\n      };\n    }>;\n  };\n}\n\n/**\n * Streaming prompt source interface\n */\nexport interface PromptSource {\n  next(): Promise<{ done: boolean; value?: SDKUserMessage }>;\n  [Symbol.asyncIterator](): AsyncIterator<SDKUserMessage>;\n}\n\n/**\n * Create a user text message\n */\nexport function createTextMessage(text: string): SDKUserMessage {\n  return {\n    type: 'user',\n    message: {\n      content: [{ type: 'text', text }]\n    }\n  };\n}\n\n/**\n * Create an image message from base64 data\n */\nexport function createImageMessage(base64Data: string, mediaType: string = 'image/png'): SDKUserMessage {\n  return {\n    type: 'user',\n    message: {\n      content: [{\n        type: 'image',\n        source: {\n          type: 'base64',\n          media_type: mediaType,\n          data: base64Data\n        }\n      }]\n    }\n  };\n}\n\n/**\n * Create a mixed content message (text + images)\n */\nexport function createMixedMessage(parts: Array<{ type: 'text'; text: string } | { type: 'image'; data: string; mediaType?: string }>): SDKUserMessage {\n  return {\n    type: 'user',\n    message: {\n      content: parts.map(part => {\n        if (part.type === 'text') {\n          return { type: 'text' as const, text: part.text };\n        } else {\n          return {\n            type: 'image' as const,\n            source: {\n              type: 'base64' as const,\n              media_type: part.mediaType || 'image/png',\n              data: part.data\n            }\n          };\n        }\n      })\n    }\n  };\n}\n\n/**\n * StreamingPromptBuilder - Build streaming prompts with fluent API\n */\nexport class StreamingPromptBuilder {\n  private messages: SDKUserMessage[] = [];\n  private delayMs: number = 0;\n\n  /**\n   * Add a text message\n   */\n  text(content: string): this {\n    this.messages.push(createTextMessage(content));\n    return this;\n  }\n\n  /**\n   * Add an image message\n   */\n  image(base64Data: string, mediaType?: string): this {\n    this.messages.push(createImageMessage(base64Data, mediaType));\n    return this;\n  }\n\n  /**\n   * Set delay between messages (ms)\n   */\n  delay(ms: number): this {\n    this.delayMs = ms;\n    return this;\n  }\n\n  /**\n   * Build async iterable for SDK\n   */\n  build(): AsyncIterable<SDKUserMessage> {\n    const messages = this.messages;\n    const delayMs = this.delayMs;\n\n    return {\n      async *[Symbol.asyncIterator]() {\n        for (const message of messages) {\n          if (delayMs > 0) {\n            await new Promise(resolve => setTimeout(resolve, delayMs));\n          }\n          yield message;\n        }\n      }\n    };\n  }\n}\n\n/**\n * Create a streaming prompt builder\n */\nexport function streamingPrompt(): StreamingPromptBuilder {\n  return new StreamingPromptBuilder();\n}\n\n/**\n * InteractivePromptStream - Stream prompts with user input callbacks\n */\nexport class InteractivePromptStream implements AsyncIterable<SDKUserMessage> {\n  private queue: SDKUserMessage[] = [];\n  private waiting: Array<(value: { done: boolean; value?: SDKUserMessage }) => void> = [];\n  private closed: boolean = false;\n\n  /**\n   * Push a message to the stream\n   */\n  push(message: SDKUserMessage): void {\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n\n    if (this.waiting.length > 0) {\n      const resolve = this.waiting.shift()!;\n      resolve({ done: false, value: message });\n    } else {\n      this.queue.push(message);\n    }\n  }\n\n  /**\n   * Push a text message\n   */\n  pushText(text: string): void {\n    this.push(createTextMessage(text));\n  }\n\n  /**\n   * Close the stream\n   */\n  close(): void {\n    this.closed = true;\n    for (const resolve of this.waiting) {\n      resolve({ done: true });\n    }\n    this.waiting = [];\n  }\n\n  /**\n   * Check if stream is closed\n   */\n  isClosed(): boolean {\n    return this.closed;\n  }\n\n  /**\n   * Get next message\n   */\n  private async next(): Promise<{ done: boolean; value?: SDKUserMessage }> {\n    if (this.queue.length > 0) {\n      return { done: false, value: this.queue.shift()! };\n    }\n\n    if (this.closed) {\n      return { done: true };\n    }\n\n    return new Promise(resolve => {\n      this.waiting.push(resolve);\n    });\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<SDKUserMessage> {\n    const self = this;\n    return {\n      async next(): Promise<IteratorResult<SDKUserMessage>> {\n        const result = await self.next();\n        if (result.done) {\n          return { done: true, value: undefined };\n        }\n        return { done: false, value: result.value! };\n      }\n    };\n  }\n}\n\n/**\n * Create an interactive prompt stream\n */\nexport function createInteractiveStream(): InteractivePromptStream {\n  return new InteractivePromptStream();\n}\n\n/**\n * Pipeline prompts from multiple sources\n */\nexport async function* pipelinePrompts(...sources: Array<AsyncIterable<SDKUserMessage>>): AsyncIterable<SDKUserMessage> {\n  for (const source of sources) {\n    for await (const message of source) {\n      yield message;\n    }\n  }\n}\n\n/**\n * Create a prompt stream from an array\n */\nexport function fromArray(messages: string[]): AsyncIterable<SDKUserMessage> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      for (const text of messages) {\n        yield createTextMessage(text);\n      }\n    }\n  };\n}\n\n/**\n * Create a prompt stream from readline (stdin)\n */\nexport function fromReadline(readline: any, prompt: string = '> '): InteractivePromptStream {\n  const stream = createInteractiveStream();\n\n  readline.on('line', (line: string) => {\n    if (line.trim()) {\n      stream.pushText(line);\n    }\n  });\n\n  readline.on('close', () => {\n    stream.close();\n  });\n\n  // Prompt for input\n  process.stdout.write(prompt);\n  readline.on('line', () => {\n    if (!stream.isClosed()) {\n      process.stdout.write(prompt);\n    }\n  });\n\n  return stream;\n}\n\n/**\n * Transform a prompt stream\n */\nexport function transformPrompts(\n  source: AsyncIterable<SDKUserMessage>,\n  transform: (message: SDKUserMessage) => SDKUserMessage | Promise<SDKUserMessage>\n): AsyncIterable<SDKUserMessage> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      for await (const message of source) {\n        yield await transform(message);\n      }\n    }\n  };\n}\n\n/**\n * Filter a prompt stream\n */\nexport function filterPrompts(\n  source: AsyncIterable<SDKUserMessage>,\n  predicate: (message: SDKUserMessage) => boolean | Promise<boolean>\n): AsyncIterable<SDKUserMessage> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      for await (const message of source) {\n        if (await predicate(message)) {\n          yield message;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Rate-limit a prompt stream\n */\nexport function rateLimitPrompts(\n  source: AsyncIterable<SDKUserMessage>,\n  minIntervalMs: number\n): AsyncIterable<SDKUserMessage> {\n  let lastEmit = 0;\n\n  return {\n    async *[Symbol.asyncIterator]() {\n      for await (const message of source) {\n        const now = Date.now();\n        const elapsed = now - lastEmit;\n\n        if (elapsed < minIntervalMs) {\n          await new Promise(resolve => setTimeout(resolve, minIntervalMs - elapsed));\n        }\n\n        lastEmit = Date.now();\n        yield message;\n      }\n    }\n  };\n}\n\n/**\n * Batch prompts together\n */\nexport function batchPrompts(\n  source: AsyncIterable<SDKUserMessage>,\n  batchSize: number,\n  separator: string = '\\n\\n'\n): AsyncIterable<SDKUserMessage> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      let batch: string[] = [];\n\n      for await (const message of source) {\n        const text = message.message.content\n          .filter((c): c is { type: 'text'; text: string } => c.type === 'text')\n          .map(c => c.text)\n          .join(' ');\n\n        batch.push(text);\n\n        if (batch.length >= batchSize) {\n          yield createTextMessage(batch.join(separator));\n          batch = [];\n        }\n      }\n\n      if (batch.length > 0) {\n        yield createTextMessage(batch.join(separator));\n      }\n    }\n  };\n}\n\n/**\n * Wrap a string or array as streaming input for SDK\n */\nexport function toStreamingInput(input: string | string[] | AsyncIterable<SDKUserMessage>): AsyncIterable<SDKUserMessage> {\n  if (typeof input === 'string') {\n    return fromArray([input]);\n  }\n\n  if (Array.isArray(input)) {\n    return fromArray(input);\n  }\n\n  return input;\n}\n\n/**\n * Log streaming input for debugging\n */\nexport function logStreamingInput(source: AsyncIterable<SDKUserMessage>, label: string = 'StreamInput'): AsyncIterable<SDKUserMessage> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      let count = 0;\n      for await (const message of source) {\n        count++;\n        logger.debug(`[${label}] Message ${count}`, {\n          type: message.type,\n          contentTypes: message.message.content.map(c => c.type)\n        });\n        yield message;\n      }\n      logger.debug(`[${label}] Stream completed`, { total: count });\n    }\n  };\n}\n"]}