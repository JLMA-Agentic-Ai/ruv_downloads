{"version":3,"file":"engine.js","sourceRoot":"","sources":["../../../src/billing/metering/engine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Usage Metering Engine\n * Real-time usage tracking and aggregation\n */\n\nimport { EventEmitter } from 'events';\nimport {\n  UsageRecord,\n  UsageMetric,\n  UsageSummary,\n  UsageLimits,\n  QuotaCheckResult,\n  BillingConfig,\n  StorageAdapter\n} from '../types.js';\n\nexport interface MeteringConfig {\n  enabled: boolean;\n  bufferSize: number;\n  flushInterval: number;\n  softLimitPercent: number;\n  hardLimitPercent: number;\n}\n\nexport class MeteringEngine extends EventEmitter {\n  private config: MeteringConfig;\n  private storage: StorageAdapter;\n  private buffer: UsageRecord[] = [];\n  private flushTimer?: NodeJS.Timeout;\n  private usageCache: Map<string, Map<UsageMetric, number>> = new Map();\n\n  constructor(storage: StorageAdapter, config?: Partial<MeteringConfig>) {\n    super();\n    this.storage = storage;\n    this.config = {\n      enabled: true,\n      bufferSize: 100,\n      flushInterval: 5000, // 5 seconds\n      softLimitPercent: 80,\n      hardLimitPercent: 100,\n      ...config\n    };\n\n    if (this.config.enabled) {\n      this.startFlushTimer();\n    }\n  }\n\n  /**\n   * Record a usage event\n   */\n  async recordUsage(record: Omit<UsageRecord, 'id' | 'timestamp' | 'billingPeriod'>): Promise<void> {\n    if (!this.config.enabled) return;\n\n    const fullRecord: UsageRecord = {\n      ...record,\n      id: this.generateId(),\n      timestamp: new Date(),\n      billingPeriod: this.getCurrentBillingPeriod()\n    };\n\n    // Update cache\n    const userMetrics = this.usageCache.get(record.subscriptionId) || new Map();\n    const current = userMetrics.get(record.metric) || 0;\n    userMetrics.set(record.metric, current + record.amount);\n    this.usageCache.set(record.subscriptionId, userMetrics);\n\n    // Buffer the record\n    this.buffer.push(fullRecord);\n\n    // Emit event\n    this.emit('usage.recorded', fullRecord);\n\n    // Flush if buffer is full\n    if (this.buffer.length >= this.config.bufferSize) {\n      await this.flush();\n    }\n  }\n\n  /**\n   * Check if usage is within quota\n   */\n  async checkQuota(\n    subscriptionId: string,\n    metric: UsageMetric,\n    limits: UsageLimits\n  ): Promise<QuotaCheckResult> {\n    const current = await this.getCurrentUsage(subscriptionId, metric);\n    const limit = this.getLimitForMetric(metric, limits);\n\n    // Unlimited\n    if (limit === -1) {\n      return {\n        allowed: true,\n        metric,\n        current,\n        limit,\n        percentUsed: 0,\n        remaining: Infinity,\n        overage: 0\n      };\n    }\n\n    const percentUsed = (current / limit) * 100;\n    const remaining = Math.max(0, limit - current);\n    const overage = Math.max(0, current - limit);\n\n    // Check soft limit\n    if (percentUsed >= this.config.softLimitPercent && percentUsed < this.config.hardLimitPercent) {\n      this.emit('quota.warning', {\n        subscriptionId,\n        metric,\n        percentUsed,\n        current,\n        limit\n      });\n    }\n\n    // Check hard limit\n    if (percentUsed >= this.config.hardLimitPercent) {\n      this.emit('quota.exceeded', {\n        subscriptionId,\n        metric,\n        current,\n        limit,\n        overage\n      });\n\n      return {\n        allowed: false,\n        metric,\n        current,\n        limit,\n        percentUsed,\n        remaining,\n        overage,\n        warning: `Quota exceeded for ${metric}. Current: ${current}, Limit: ${limit}`\n      };\n    }\n\n    return {\n      allowed: true,\n      metric,\n      current,\n      limit,\n      percentUsed,\n      remaining,\n      overage\n    };\n  }\n\n  /**\n   * Get usage summary for a subscription\n   */\n  async getUsageSummary(subscriptionId: string, limits: UsageLimits): Promise<UsageSummary> {\n    const period = this.getCurrentBillingPeriod();\n    const metrics = new Map<UsageMetric, number>();\n    const percentUsed = new Map<UsageMetric, number>();\n    const overages = new Map<UsageMetric, number>();\n\n    // Get all metrics\n    const allMetrics = Object.values(UsageMetric);\n\n    for (const metric of allMetrics) {\n      const current = await this.getCurrentUsage(subscriptionId, metric);\n      const limit = this.getLimitForMetric(metric, limits);\n\n      metrics.set(metric, current);\n\n      if (limit !== -1) {\n        const percent = (current / limit) * 100;\n        percentUsed.set(metric, percent);\n\n        if (current > limit) {\n          overages.set(metric, current - limit);\n        }\n      }\n    }\n\n    // Calculate estimated cost based on overages\n    const estimatedCost = this.calculateOverageCost(overages);\n\n    return {\n      subscriptionId,\n      userId: '', // Will be set by caller\n      period,\n      metrics,\n      limits,\n      percentUsed,\n      overages,\n      estimatedCost\n    };\n  }\n\n  /**\n   * Get current usage for a metric\n   */\n  private async getCurrentUsage(subscriptionId: string, metric: UsageMetric): Promise<number> {\n    // Check cache first\n    const cached = this.usageCache.get(subscriptionId)?.get(metric);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // Query storage\n    const period = this.getCurrentBillingPeriod();\n    const records = await this.storage.getUsageRecords(subscriptionId, period);\n\n    const total = records\n      .filter(r => r.metric === metric)\n      .reduce((sum, r) => sum + r.amount, 0);\n\n    // Update cache\n    const userMetrics = this.usageCache.get(subscriptionId) || new Map();\n    userMetrics.set(metric, total);\n    this.usageCache.set(subscriptionId, userMetrics);\n\n    return total;\n  }\n\n  /**\n   * Flush buffered records to storage\n   */\n  private async flush(): Promise<void> {\n    if (this.buffer.length === 0) return;\n\n    const records = [...this.buffer];\n    this.buffer = [];\n\n    try {\n      await Promise.all(records.map(r => this.storage.saveUsageRecord(r)));\n      this.emit('flush.success', { count: records.length });\n    } catch (error) {\n      this.emit('flush.error', error);\n      // Re-add to buffer on error\n      this.buffer.unshift(...records);\n    }\n  }\n\n  /**\n   * Start automatic flush timer\n   */\n  private startFlushTimer(): void {\n    this.flushTimer = setInterval(() => {\n      this.flush();\n    }, this.config.flushInterval);\n  }\n\n  /**\n   * Stop the metering engine\n   */\n  async stop(): Promise<void> {\n    if (this.flushTimer) {\n      clearInterval(this.flushTimer);\n    }\n    await this.flush();\n  }\n\n  /**\n   * Clear cache for a subscription\n   */\n  clearCache(subscriptionId?: string): void {\n    if (subscriptionId) {\n      this.usageCache.delete(subscriptionId);\n    } else {\n      this.usageCache.clear();\n    }\n  }\n\n  private getLimitForMetric(metric: UsageMetric, limits: UsageLimits): number {\n    const metricToLimitMap: Record<UsageMetric, keyof UsageLimits> = {\n      [UsageMetric.AgentHours]: 'maxAgentHours',\n      [UsageMetric.Deployments]: 'maxDeployments',\n      [UsageMetric.APIRequests]: 'maxAPIRequests',\n      [UsageMetric.StorageGB]: 'maxStorageGB',\n      [UsageMetric.SwarmSize]: 'maxSwarmSize',\n      [UsageMetric.GPUHours]: 'maxGPUHours',\n      [UsageMetric.BandwidthGB]: 'maxBandwidthGB',\n      [UsageMetric.ConcurrentJobs]: 'maxConcurrentJobs',\n      [UsageMetric.TeamMembers]: 'maxTeamMembers',\n      [UsageMetric.CustomDomains]: 'maxCustomDomains'\n    };\n\n    return limits[metricToLimitMap[metric]];\n  }\n\n  private calculateOverageCost(overages: Map<UsageMetric, number>): number {\n    // Example overage rates (per unit)\n    const rates: Record<UsageMetric, number> = {\n      [UsageMetric.AgentHours]: 0.50,\n      [UsageMetric.Deployments]: 5.00,\n      [UsageMetric.APIRequests]: 0.0001,\n      [UsageMetric.StorageGB]: 0.10,\n      [UsageMetric.SwarmSize]: 10.00,\n      [UsageMetric.GPUHours]: 2.00,\n      [UsageMetric.BandwidthGB]: 0.05,\n      [UsageMetric.ConcurrentJobs]: 5.00,\n      [UsageMetric.TeamMembers]: 15.00,\n      [UsageMetric.CustomDomains]: 10.00\n    };\n\n    let total = 0;\n    overages.forEach((amount, metric) => {\n      total += amount * (rates[metric] || 0);\n    });\n\n    return total;\n  }\n\n  private getCurrentBillingPeriod(): string {\n    const now = new Date();\n    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;\n  }\n\n  private generateId(): string {\n    return `usage_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n"]}