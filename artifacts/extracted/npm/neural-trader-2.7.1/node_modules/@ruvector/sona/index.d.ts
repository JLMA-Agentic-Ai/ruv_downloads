/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** SONA configuration for Node.js */
export interface JsSonaConfig {
  /** Hidden dimension size */
  hiddenDim: number
  /** Embedding dimension (defaults to hidden_dim) */
  embeddingDim?: number
  /** Micro-LoRA rank (1-2, default: 1) */
  microLoraRank?: number
  /** Base LoRA rank (default: 8) */
  baseLoraRank?: number
  /** Micro-LoRA learning rate (default: 0.001) */
  microLoraLr?: number
  /** Base LoRA learning rate (default: 0.0001) */
  baseLoraLr?: number
  /** EWC lambda regularization (default: 1000.0) */
  ewcLambda?: number
  /** Number of pattern clusters (default: 50) */
  patternClusters?: number
  /** Trajectory buffer capacity (default: 10000) */
  trajectoryCapacity?: number
  /** Background learning interval in ms (default: 3600000 = 1 hour) */
  backgroundIntervalMs?: number
  /** Quality threshold for learning (default: 0.5) */
  qualityThreshold?: number
  /** Enable SIMD optimizations (default: true) */
  enableSimd?: boolean
}
/** Learned pattern for Node.js */
export interface JsLearnedPattern {
  /** Pattern identifier */
  id: string
  /** Cluster centroid embedding */
  centroid: Array<number>
  /** Number of trajectories in cluster */
  clusterSize: number
  /** Total weight of trajectories */
  totalWeight: number
  /** Average quality of member trajectories */
  avgQuality: number
  /** Creation timestamp (Unix seconds) */
  createdAt: string
  /** Last access timestamp (Unix seconds) */
  lastAccessed: string
  /** Total access count */
  accessCount: number
  /** Pattern type */
  patternType: string
}
/** Node.js SONA Engine wrapper */
export declare class SonaEngine {
  /**
   * Create a new SONA engine with default configuration
   * @param hidden_dim - Hidden dimension size (e.g., 256, 512)
   */
  constructor(hiddenDim: number)
  /**
   * Create with custom configuration
   * @param config - Custom SONA configuration object
   */
  static withConfig(config: JsSonaConfig): SonaEngine
  /**
   * Start a new trajectory recording
   * @param query_embedding - Query embedding vector (Float64Array)
   * @returns Trajectory ID for adding steps
   */
  beginTrajectory(queryEmbedding: Array<number>): number
  /**
   * Add a step to trajectory
   * @param trajectory_id - Trajectory ID from beginTrajectory
   * @param activations - Layer activations (Float64Array)
   * @param attention_weights - Attention weights (Float64Array)
   * @param reward - Reward signal for this step
   */
  addTrajectoryStep(trajectoryId: number, activations: Array<number>, attentionWeights: Array<number>, reward: number): void
  /**
   * Set model route for trajectory
   * @param trajectory_id - Trajectory ID
   * @param route - Model route identifier
   */
  setTrajectoryRoute(trajectoryId: number, route: string): void
  /**
   * Add context to trajectory
   * @param trajectory_id - Trajectory ID
   * @param context_id - Context identifier
   */
  addTrajectoryContext(trajectoryId: number, contextId: string): void
  /**
   * Complete a trajectory and submit for learning
   * @param trajectory_id - Trajectory ID
   * @param quality - Final quality score [0.0, 1.0]
   */
  endTrajectory(trajectoryId: number, quality: number): void
  /**
   * Apply micro-LoRA transformation to input
   * @param input - Input vector (Float64Array)
   * @returns Transformed output vector
   */
  applyMicroLora(input: Array<number>): Array<number>
  /**
   * Apply base-LoRA transformation to layer output
   * @param layer_idx - Layer index
   * @param input - Input vector (Float64Array)
   * @returns Transformed output vector
   */
  applyBaseLora(layerIdx: number, input: Array<number>): Array<number>
  /**
   * Run background learning cycle if due
   * @returns Optional status message if cycle was executed
   */
  tick(): string | null
  /**
   * Force background learning cycle immediately
   * @returns Status message with learning results
   */
  forceLearn(): string
  /** Flush instant loop updates */
  flush(): void
  /**
   * Find similar learned patterns to query
   * @param query_embedding - Query embedding vector
   * @param k - Number of patterns to return
   * @returns Array of learned patterns
   */
  findPatterns(queryEmbedding: Array<number>, k: number): Array<JsLearnedPattern>
  /**
   * Get engine statistics as JSON string
   * @returns Statistics object as JSON string
   */
  getStats(): string
  /**
   * Enable or disable the engine
   * @param enabled - Whether to enable the engine
   */
  setEnabled(enabled: boolean): void
  /**
   * Check if engine is enabled
   * @returns Whether the engine is enabled
   */
  isEnabled(): boolean
}
